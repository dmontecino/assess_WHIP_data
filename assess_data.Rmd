---
title: "WHIP DATA QUALITY ASSESSMENT"
output: html_document
params:
  spec: spec
  obs: obs
  country.of.interest: country.of.interest
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r load packages , echo=FALSE, warning=FALSE, message=FALSE, eval=T}
library(knitr)
library(kableExtra)
library(stringi)
library(dplyr)
library(tibble)
library(rworldmap)
library(tidyverse)
library(plyr)

```

```{r load data, echo=FALSE, warning=FALSE, message=FALSE}

spec<-params$spec

obs<-params$obs


# modify column names to delete weird characters

colnames(spec)=sapply(names(spec), function(x) gsub(" ", "_", x, fixed = TRUE), USE.NAMES = F)
colnames(spec)=sapply(names(spec), function(x) gsub("/", "_", x, fixed = TRUE), USE.NAMES = F)
colnames(spec)=sapply(names(spec), function(x) gsub("_-", "", x, fixed = TRUE), USE.NAMES = F)
colnames(spec)=sapply(names(spec), function(x) gsub(" ", "", x, fixed = TRUE), USE.NAMES = F)


colnames(spec)=stri_trans_general(str = colnames(spec), 
                                 id = "Latin-ASCII")

colnames(obs)=sapply(names(obs), function(x) gsub(" ", "_", x, fixed = TRUE), USE.NAMES = F)
colnames(obs)=sapply(names(obs), function(x) gsub("/", "_", x, fixed = TRUE), USE.NAMES = F)
colnames(obs)=sapply(names(obs), function(x) gsub("_-", "", x, fixed = TRUE), USE.NAMES = F)
colnames(obs)=sapply(names(obs), function(x) gsub(" ", "", x, fixed = TRUE), USE.NAMES = F)


colnames(obs)=stri_trans_general(str = colnames(obs), 
                                  id = "Latin-ASCII")

# spec=spec[!(spec$Tags%in%c("Delete", "Delete,Test")),]
# spec=spec[!(spec$Tags%in%c("Test,Delete", "Test")),]
spec=spec[!(grepl("test", spec$Projects, ignore.case = T)),]
spec=spec[!(grepl("delete", spec$Projects, ignore.case = T)),]
spec=spec[!(grepl("test", spec$Tags, ignore.case = T)),]
spec=spec[!(grepl("delete", spec$Tags, ignore.case = T)),]

# obs=obs[!(obs$Tags%in%c("Delete", "Delete,Test")),]
# obs=obs[!(obs$Tags%in%c("Test,Delete", "Test")),]
obs=obs[!(grepl("test", obs$Projects, ignore.case = T)),]
obs=obs[!(grepl("delete", obs$Projects, ignore.case = T)),]
obs=obs[!(grepl("test", obs$Tags, ignore.case = T)),]
obs=obs[!(grepl("delete", obs$Tags, ignore.case = T)),]

# delete a WHIP test. the fact that it is a test is mentioned in an open text box
obs=obs[obs$Event_Code!="WCS.100035",]


# Set all Lao PDR as Laos in spec and obs
if(any(spec$Country=="Laos", na.rm = T)){spec[which(spec$Country=="Laos"), ]$Country="Lao PDR"}
if(any(obs$Country=="Laos", na.rm = T)){obs[which(obs$Country=="Laos"), ]$Country="Lao PDR"}


countries=sort(c("Cambodia", "Lao PDR", "Vietnam"))

spec=spec%>%filter(Country%in%c(countries, NA))
obs=obs%>%filter(Country%in%c(countries, NA))



# Divide data per country for specimens including rows with country as NA

data.per.country.spec=
  # lapply(sort(unique(spec$Country)), function(x)
    lapply(countries, function(x)
    spec[which(spec$Country==x),])
  
data.per.country.spec.na= # specimens with NAs in the country
  list(spec[is.na(spec$Country),])

  #full set 
data.per.country.spec=c(data.per.country.spec, data.per.country.spec.na)
  
#names(data.per.country.spec)= c(sort(unique(spec$Country)), "NA_Country")
names(data.per.country.spec)= c(countries, "NA_Country")



# add the country name to those specimens with unknown country based on the project tag
if(nrow(data.per.country.spec$NA_Country)>0){
  
  if(nrow(data.per.country.spec$NA_Country)>1){
  data.per.country.spec$NA_Country$Country=
  apply(sapply(countries, function(x) 
    grepl(x, data.per.country.spec$NA_Country$Projects, 
          ignore.case = T)), MARGIN = 1, function(y) 
            ifelse(any(y), names(y[y==T]), "NA"))}
  
  if(nrow(data.per.country.spec$NA_Country)==1){
  
    temp=sapply(countries, function(x) 
    grepl(x, data.per.country.spec$NA_Country$Projects, 
          ignore.case = T))
    
  data.per.country.spec$NA_Country$Country=
  ifelse(any(temp), names(temp[temp==T]), "NA")}
}






# Divide data per country for observations including rows with country as NA

data.per.country.obs=
  lapply(countries, function(x)
  # lapply(sort(unique(obs$Country)), function(x)
    obs[which(obs$Country==x),])
  
data.per.country.obs.na= # specimens with NAs in the country
  list(obs[is.na(obs$Country),])

  #full set 
data.per.country.obs=c(data.per.country.obs, data.per.country.obs.na)
  
names(data.per.country.obs)= c(sort(unique(obs$Country)), "NA_Country")


#add the country name to those events with unknown country based on the project tag
if(nrow(data.per.country.obs$NA_Country)>0){
  
  if(nrow(data.per.country.obs$NA_Country)>1){
  data.per.country.obs$NA_Country$Country=
  apply(sapply(countries, function(x) 
    grepl(x, data.per.country.obs$NA_Country$Projects, 
          ignore.case = T)), MARGIN = 1, function(y) 
            ifelse(any(y), names(y[y==T]), "NA"))}
  
  if(nrow(data.per.country.obs$NA_Country)==1){
  
    temp=sapply(countries, function(x) 
    grepl(x, data.per.country.obs$NA_Country$Projects, 
          ignore.case = T))
    
  data.per.country.obs$NA_Country$Country=
  ifelse(any(temp), names(temp[temp==T]), "NA")}
}

data.per.country.spec=data.per.country.spec[sapply(data.per.country.spec, nrow)>0]

```

<!-- ## EVENT CROSS REFERENCE NUMBER -->

```{r checking event cross reference number, echo=FALSE, eval=F}

spec$ev_cross_reference_number

```

## EVENTS 


```{r checking events codes, echo=FALSE, eval=F}

# Are there any na's in the event codes

any.nas.event.code.specimen=any(is.na(spec$Event_Code)) # no NAs as it should.

any.nas.event.code.observation=any(is.na(obs$Event_Code)) # no NAs as it should.

if(any.nas.event.code.specimen==F & any.nas.event.code.observation==F){
  
  message("All rows in the observation and specimen sheets have event codes")}else{
    
  message("The observation or specimen sheets have empty event codes")}


# Do all events codes start with "WCS"

event.code.does.not.start.with.WCS.spec=any(!grepl("WCS", spec$Event_Code))

event.code.does.not.start.with.WCS.obs=any(!grepl("WCS", spec$Event_Code))


if(event.code.does.not.start.with.WCS.spec==F & event.code.does.not.start.with.WCS.obs==F){
  
  message("All event codes in the specimen and observation sheets start with WCS")}else{
    
  message("Not all event codes start with WCS. 
          This could be in the observation or the specimen sheet")}
```

### EVENT DATES
#
##### Are the start dates provided for all the events?
#
#
```{r checking start dates of events, echo=FALSE, warning=FALSE, cache=F, eval=T}

# ----------------------------- #
# ---- START AND END DATES ---- #
# ----------------------------- #

names.countries.obs.spec=sort(unique(c(names(data.per.country.obs),
                                      names(data.per.country.spec))))

# specimens and observations per country

event.codes.per.country=vector(mode = "list", 
                               length = length(names.countries.obs.spec))

names(event.codes.per.country)=names.countries.obs.spec
  
event.codes.per.country=lapply(names.countries.obs.spec, function(x)
  
  rbind(data.per.country.obs[[x]], data.per.country.spec[[x]]))

names(event.codes.per.country)=names.countries.obs.spec
 


# events wo the start date

event.codes.start.dates.not.provided.per.country=
  lapply(event.codes.per.country, function(x)
  x%>%
    filter(is.na(Start_date))%>%
    dplyr::select(Country,Event_Code)%>%
    distinct(Country, Event_Code))
    

# add the country name to those events with unknown country based on the project tag
if(nrow(event.codes.start.dates.not.provided.per.country$NA_Country)>0){
  
  event.codes.start.dates.not.provided.per.country$NA_Country$Country=
  unlist(apply(sapply(countries, function(x) 
    grepl(x, event.codes.start.dates.not.provided.per.country$NA_Country$Projects, 
          ignore.case = T)), MARGIN = 1, function(y)
            ifelse(all(y==F), "NA_Country", names(y)[which(y)])),
            use.names = F)}


# if there are rows with wrong latitude
if(nrow(do.call(rbind, event.codes.start.dates.not.provided.per.country))>0){  

event.codes.start.dates.not.provided.per.country=do.call(
  rbind, event.codes.start.dates.not.provided.per.country)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
event.codes.start.dates.not.provided.per.country=
lapply(sort(unique(event.codes.start.dates.not.provided.per.country$Country)), function(x) 
  event.codes.start.dates.not.provided.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code)%>%
  distinct(Country, Event_Code))

# name the list
names(event.codes.start.dates.not.provided.per.country)=sapply(
  event.codes.start.dates.not.provided.per.country, function(x) unique(x$Country))
    
# order by event code
event.codes.start.dates.not.provided.per.country=
  lapply(event.codes.start.dates.not.provided.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
event.codes.start.dates.not.provided.per.country.df=
  lapply(event.codes.start.dates.not.provided.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


  event.codes.start.dates.not.provided.per.country.df=data.frame(
    Country=names(event.codes.start.dates.not.provided.per.country.df), 
    Event_Codes=unlist(event.codes.start.dates.not.provided.per.country.df, use.names = F))

   event.codes.start.dates.not.provided.per.country.df=
     event.codes.start.dates.not.provided.per.country.df[
       event.codes.start.dates.not.provided.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(event.codes.start.dates.not.provided.per.country.df)=NULL 

   # subset to specific country
event.codes.start.dates.not.provided.per.country.df=event.codes.start.dates.not.provided.per.country.df%>%
                                                    filter(Country==params$country.of.interest)

if(nrow(event.codes.start.dates.not.provided.per.country.df)>0){

  
  message("No. Not all the events have their start dates are provided. These are the events without start date per country.")
    
  # table
  kableExtra::kbl(event.codes.start.dates.not.provided.per.country.df, 
                  caption = "Event codes without the start date per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "50em")}}

if(!exists("event.codes.start.dates.not.provided.per.country.df") |
    exists("event.codes.start.dates.not.provided.per.country.df") && nrow(event.codes.start.dates.not.provided.per.country.df)==0){  
  
 event.codes.start.dates.not.provided.per.country=list(data.frame(Country="", Event_Code="" ))


        message("Yes, start dates are provided for all events")}
  
```
#
##### Are the end dates provided for all the events?
#
#
```{r checking end dates of events, echo=FALSE, warning=FALSE, cache=F, eval=T}
# events wo the start date

event.codes.end.dates.not.provided.per.country=
  lapply(event.codes.per.country, function(x)
  x%>%
    filter(is.na(End_date))%>%
    dplyr::select(Country,Event_Code)%>%
    distinct(Country, Event_Code))



# if there are rows with wrong latitude
if(nrow(do.call(rbind, event.codes.end.dates.not.provided.per.country))>0){  

event.codes.end.dates.not.provided.per.country=do.call(
  rbind, event.codes.end.dates.not.provided.per.country)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
event.codes.end.dates.not.provided.per.country=
lapply(sort(unique(event.codes.end.dates.not.provided.per.country$Country)), function(x) 
  event.codes.end.dates.not.provided.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code)%>%
  distinct(Country, Event_Code))

# name the list
names(event.codes.end.dates.not.provided.per.country)=sapply(
  event.codes.end.dates.not.provided.per.country, function(x) unique(x$Country))
    
# order by event code
event.codes.end.dates.not.provided.per.country=
  lapply(event.codes.end.dates.not.provided.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
event.codes.end.dates.not.provided.per.country.df=
  lapply(event.codes.end.dates.not.provided.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


  event.codes.end.dates.not.provided.per.country.df=data.frame(
    Country=names(event.codes.end.dates.not.provided.per.country.df), 
    Event_Codes=unlist(event.codes.end.dates.not.provided.per.country.df, use.names = F))

   event.codes.end.dates.not.provided.per.country.df=
     event.codes.end.dates.not.provided.per.country.df[
       event.codes.end.dates.not.provided.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(event.codes.end.dates.not.provided.per.country.df)=NULL 
     
     # subset to specific country
event.codes.end.dates.not.provided.per.country.df=event.codes.end.dates.not.provided.per.country.df%>%
                                                    filter(Country==params$country.of.interest)

if(nrow(event.codes.end.dates.not.provided.per.country.df)>0){


  message("No. Not all the events have their end dates are provided. These are the events without end date per country.")
    
  # table
  kableExtra::kbl(event.codes.end.dates.not.provided.per.country.df, 
                  caption = "Event codes without the end date per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "50em")}}

 if(!exists("event.codes.end.dates.not.provided.per.country.df") |
    exists("event.codes.end.dates.not.provided.per.country.df") && nrow(event.codes.end.dates.not.provided.per.country.df)==0){  
   
     event.codes.end.dates.not.provided.per.country=list(data.frame(Country="", Event_Code="" ))

    message("Yes, end dates are provided for all the events")}

  
  
```
#
##### Does the interpretation occurs since the event started?
#
#
```{r interpretation dates, echo=FALSE, warning=FALSE, eval=T, cache=F}


event.codes.date.interpretation.earlier.start.date.per.country=
  lapply(event.codes.per.country, function(x)
  x%>%
    filter(!is.na(Interpretation_date))%>%
    filter(!(as.Date(Start_date)<=as.Date(Interpretation_date)))%>%
    dplyr::select(Country,Event_Code)%>%
    distinct(Country, Event_Code))



# if there are rows with wrong latitude
if(nrow(do.call(rbind, event.codes.date.interpretation.earlier.start.date.per.country))>0){  

date.interpretation.earlier.start.date.per.country=do.call(
  rbind, event.codes.date.interpretation.earlier.start.date.per.country)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
date.interpretation.earlier.start.date.per.country=
lapply(sort(unique(date.interpretation.earlier.start.date.per.country$Country)), function(x) 
  date.interpretation.earlier.start.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code)%>%
  distinct(Country, Event_Code))

# name the list
names(date.interpretation.earlier.start.date.per.country)=sapply(
  date.interpretation.earlier.start.date.per.country, function(x) unique(x$Country))
    
# order by event code
date.interpretation.earlier.start.date.per.country=
  lapply(date.interpretation.earlier.start.date.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
event.codes.date.interpretation.earlier.start.date.per.country.df=
  lapply(date.interpretation.earlier.start.date.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


  event.codes.date.interpretation.earlier.start.date.per.country.df=data.frame(
    Country=names(event.codes.date.interpretation.earlier.start.date.per.country.df), 
    Event_Codes=unlist(event.codes.date.interpretation.earlier.start.date.per.country.df, use.names = F))

   event.codes.date.interpretation.earlier.start.date.per.country.df=
     event.codes.date.interpretation.earlier.start.date.per.country.df[
       event.codes.date.interpretation.earlier.start.date.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(event.codes.date.interpretation.earlier.start.date.per.country.df)=NULL 
   
     # subset to specific country
event.codes.date.interpretation.earlier.start.date.per.country.df=event.codes.date.interpretation.earlier.start.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(event.codes.date.interpretation.earlier.start.date.per.country.df)>0){

  
# Show the results
  message("No. Not all the interpretations occur since the start date. These are the events with inconsistency between
the interpretation date and the start date")

  kableExtra::kbl(event.codes.date.interpretation.earlier.start.date.per.country.df,
                  caption = "Event codes with inconsistent start date and date of interpretation") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "30em")
}}
  
if(!exists("event.codes.date.interpretation.earlier.start.date.per.country.df") |
    exists("event.codes.date.interpretation.earlier.start.date.per.country.df") && nrow(event.codes.date.interpretation.earlier.start.date.per.country.df)==0){  

  date.interpretation.earlier.start.date.per.country=list(
    data.frame(Country="", Event_Code="" ))
   
  rownames(date.interpretation.earlier.start.date.per.country[[1]])<-NULL
 

   message("Yes, all interpretations occur since the corresponding start date")}

```
#
##### Does the interpretation occur since the event ended?
#
#
```{r interpretation dates 2, echo=FALSE, warning=FALSE, eval=T, cache=F}


event.codes.date.interpretation.earlier.end.date.per.country=
  lapply(event.codes.per.country, function(x)
  x%>%
    filter(!is.na(Interpretation_date))%>%
    filter(!(as.Date(End_date)<=as.Date(Interpretation_date)))%>%
    dplyr::select(Country,Event_Code)%>%
    distinct(Country, Event_Code))



# if there are rows with wrong latitude
if(nrow(do.call(rbind, event.codes.date.interpretation.earlier.end.date.per.country))>0){  

date.interpretation.earlier.end.date.per.country=do.call(
  rbind, event.codes.date.interpretation.earlier.end.date.per.country)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
date.interpretation.earlier.end.date.per.country=
lapply(sort(unique(date.interpretation.earlier.end.date.per.country$Country)), function(x) 
  date.interpretation.earlier.end.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code)%>%
  distinct(Country, Event_Code))

# name the list
names(date.interpretation.earlier.end.date.per.country)=sapply(
  date.interpretation.earlier.end.date.per.country, function(x) unique(x$Country))
    
# order by event code
date.interpretation.earlier.end.date.per.country=
  lapply(date.interpretation.earlier.end.date.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
event.codes.date.interpretation.earlier.end.date.per.country.df=
  lapply(date.interpretation.earlier.end.date.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


  event.codes.date.interpretation.earlier.end.date.per.country.df=data.frame(
    Country=names(event.codes.date.interpretation.earlier.end.date.per.country.df), 
    Event_Codes=unlist(event.codes.date.interpretation.earlier.end.date.per.country.df, use.names = F))

   event.codes.date.interpretation.earlier.end.date.per.country.df=
     event.codes.date.interpretation.earlier.end.date.per.country.df[
       event.codes.date.interpretation.earlier.end.date.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(event.codes.date.interpretation.earlier.end.date.per.country.df)=NULL 
   
     # subset to specific country
event.codes.date.interpretation.earlier.end.date.per.country.df=
  event.codes.date.interpretation.earlier.end.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(event.codes.date.interpretation.earlier.start.date.per.country.df)>0){
  
  
  message("No. Not all the interpretation dates occur after the end date. These are the events with inconsistency between
the interpretation date and the end date")

  
  kableExtra::kbl(event.codes.date.interpretation.earlier.end.date.per.country.df, 
                  caption = "Event codes with inconsistent end date and date of interpretation") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "30em")
}}

if(!exists("event.codes.date.interpretation.earlier.end.date.per.country.df") |
    exists("event.codes.date.interpretation.earlier.end.date.per.country.df") && nrow(event.codes.date.interpretation.earlier.end.date.per.country.df)==0){  

  
  date.interpretation.earlier.end.date.per.country=list(
    data.frame(Country="", Event_Code="" ))
   
  rownames(date.interpretation.earlier.end.date.per.country[[1]])<-NULL
 
   message("Yes, all interpretation dates occur after the corresponding end date")}

```

### COUNTRY OF THE EVENTS 
#
##### Is the country provided for all the events?
#
#
```{r country of the events, echo=FALSE, warning=FALSE, eval=T, cache=F}

# this apply for event.codes.per.country$NA_Country$Projects
 
if(nrow(event.codes.per.country$NA_Country)>0){
  
# list per county when the country can be extracted from the project tags
event.codes.wo.country.per.country=
lapply(
sort(unique(event.codes.per.country$NA_Country$Country)), function(x)
  event.codes.per.country$NA_Country%>%filter(Country==x)%>%
  dplyr::select(Country,Event_Code)%>%
  distinct(Country, Event_Code))
      

# name the list
names(event.codes.wo.country.per.country)=sapply(
  event.codes.wo.country.per.country, function(x) unique(x$Country))
    
# order by event code
event.codes.wo.country.per.country=
  lapply(event.codes.wo.country.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
event.codes.wo.country.per.country.df=
  lapply(event.codes.wo.country.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


event.codes.wo.country.per.country.df=data.frame(
  Country=names(event.codes.wo.country.per.country.df), 
  Event_Codes=unlist(event.codes.wo.country.per.country.df, use.names = F))

event.codes.wo.country.per.country.df=
 event.codes.wo.country.per.country.df[
   event.codes.wo.country.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(event.codes.wo.country.per.country.df)=NULL 
   
     # subset to specific country
event.codes.wo.country.per.country.df=
  event.codes.wo.country.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(event.codes.wo.country.per.country.df)>0){
  
  
# Show the results

    message("No. Not all events have the country provided.
These are the Events without country per country.  
The country is provided based on the project tag")
  
    kableExtra::kbl(event.codes.wo.country.per.country.df, 
                    caption = "Event codes without country per country. Country based on project tag") %>%
      kableExtra::kable_paper(full_width = F) %>%
      kableExtra::column_spec(1, bold = T, border_right = T) %>%
      kableExtra::column_spec(2, width = "30em")
}}

if(!exists("event.codes.wo.country.per.country.df") |
    exists("event.codes.wo.country.per.country.df") && nrow(event.codes.wo.country.per.country.df)==0){  

    
    message("Yes, all the events have the country assigned")
  
  event.codes.wo.country.per.country=list(data.frame(
    Country="", 
    Event_Code=""))
  
    rownames(event.codes.wo.country.per.country[[1]])<-NULL

  }
  
```
#
##### Does the country, when provided, exist? Or is it a bogus random word?
#
#
```{r check countries, echo=FALSE, warning=FALSE, eval=T, cache=F}

# events.countries.provided=
  
  event.codes.per.country.temp=event.codes.per.country
  event.codes.per.country.temp[["NA_Country"]] <- NULL # remove observations wo country
  
  event.codes.countries.provided=
  do.call(rbind, event.codes.per.country.temp) 

  
# dplyr::select those rows with bogus countries
events.countries.provided.bogus=
  event.codes.countries.provided[
    !(event.codes.countries.provided$Country%in%countries),]
  

  # create a list with the codes of he events that do have country but is bogus.
  # The country is based on the project tag field
# add the country name to those events with unknown country based on the project tag
if(nrow(events.countries.provided.bogus)>0){


# split the data by country 
events.countries.provided.bogus.per.country=
lapply(sort(unique(events.countries.provided.bogus$Country)), function(x) 
  events.countries.provided.bogus%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code)%>%
  distinct(Country, Event_Code))

# name the list
names(events.countries.provided.bogus.per.country)=sapply(
  events.countries.provided.bogus.per.country, function(x) unique(x$Country))
    
# order by event code
events.countries.provided.bogus.per.country=
  lapply(events.countries.provided.bogus.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
events.countries.provided.bogus.per.country.df=
  lapply(events.countries.provided.bogus.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


  events.countries.provided.bogus.per.country.df=data.frame(
    Country=names(events.countries.provided.bogus.per.country.df), 
    Event_Codes=unlist(events.countries.provided.bogus.per.country.df, use.names = F))

   events.countries.provided.bogus.per.country.df=
     events.countries.provided.bogus.per.country.df[
       events.countries.provided.bogus.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(events.countries.provided.bogus.per.country.df)=NULL 
   
     # subset to specific country
events.countries.provided.bogus.per.country.df=
  events.countries.provided.bogus.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(events.countries.provided.bogus.per.country.df)>0){
  
  
# Show the results
      
    message("No. Not all the countries provided are acceptable. These are the events without a proper country per country. The country provided is based on the project tag")
  
    kableExtra::kbl(events.countries.provided.bogus.per.country.df, 
                    caption = "Event codes with incorrect country per country. The country is based on the project tag") %>%
      kableExtra::kable_paper(full_width = F) %>%
      kableExtra::column_spec(1, bold = T, border_right = T) %>%
      kableExtra::column_spec(2, width = "30em")
}}

if(!exists("events.countries.provided.bogus.per.country.df") |
    exists("events.countries.provided.bogus.per.country.df") && nrow(events.countries.provided.bogus.per.country.df)==0){  

   event.codes.bogus.country.per.country=list(data.frame(Country="", Event_Code=""))
   
   rownames(event.codes.bogus.country.per.country[[1]])<-NULL
         
   
    message("Yes, all the countries provided are appropriate")}

  
```


### LATITUDE AND LONGITUDE OF THE EVENTS 

##### Are the latitude and longitude coordinates of the events feasible using decimal degress?
#
##### Latitude
#
#
```{r check latitude, echo=FALSE, warning=FALSE, eval=T, cache=F}

 # based on the project tag, find the country of those events wo country

for(i in 1:length(event.codes.per.country)){
  event.codes.per.country[[i]]$Latitude=
  as.numeric(event.codes.per.country[[i]]$Latitude)}



event.codes.wrong.lat.per.country=
lapply(event.codes.per.country, function(x)
  x%>%filter(Latitude>90 | Latitude<(-90))%>%
  dplyr::select(Country,Event_Code, Projects)%>%
  distinct(Country,Event_Code, Projects))


# if there are rows with wrong latitude
if(nrow(do.call(rbind, event.codes.wrong.lat.per.country))>0){  

event.codes.wrong.lat.per.country=do.call(rbind, event.codes.wrong.lat.per.country)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
event.codes.wrong.lat.per.country=
lapply(sort(unique(event.codes.wrong.lat.per.country$Country)), function(x) 
  event.codes.wrong.lat.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code)%>%
  distinct(Country, Event_Code))

# name the list
names(event.codes.wrong.lat.per.country)=sapply(
  event.codes.wrong.lat.per.country, function(x) unique(x$Country))
    
# order by event code
event.codes.wrong.lat.per.country=
  lapply(event.codes.wrong.lat.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
event.codes.wrong.lat.per.country.df=
  lapply(event.codes.wrong.lat.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


  event.codes.wrong.lat.per.country.df=data.frame(
    Country=names(event.codes.wrong.lat.per.country.df), 
    Event_Codes=unlist(event.codes.wrong.lat.per.country.df, use.names = F))

   event.codes.wrong.lat.per.country.df=
     event.codes.wrong.lat.per.country.df[event.codes.wrong.lat.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(event.codes.wrong.lat.per.country.df)=NULL 
  
       # subset to specific country
event.codes.wrong.lat.per.country.df=
  event.codes.wrong.lat.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(event.codes.wrong.lat.per.country.df)>0){
 
  
# Show the results
    
    message("No. Not all the latitudes values reported are feasible These are the events with impossible latitude values
(in decimal degrees) per country.")
    
    kableExtra::kbl(event.codes.wrong.lat.per.country.df, 
                    caption = "Event codes with implausible latitude values (in decimal degrees) per country") %>%
      kableExtra::kable_paper(full_width = F) %>%
      kableExtra::column_spec(1, bold = T, border_right = T) %>%
      kableExtra::column_spec(2, width = "30em")
}}

if(!exists("event.codes.wrong.lat.per.country.df") |
    exists("event.codes.wrong.lat.per.country.df") && nrow(event.codes.wrong.lat.per.country.df)==0){  
    
    event.codes.wrong.lat.per.country=list(data.frame(Country="", Event_Code=""))
   
   rownames(event.codes.wrong.lat.per.country[[1]])<-NULL
    
    message("Yes, all the latitude values reported are feasible (in decimal degrees)")}
  
```
#
##### Longitude
#
#
```{r check Longitude, echo=FALSE, warning=FALSE, eval=T, cache=F}

for(i in 1:length(event.codes.per.country)){
  event.codes.per.country[[i]]$Longitude=
  as.numeric(event.codes.per.country[[i]]$Longitude)}



event.codes.wrong.lon.per.country=
lapply(event.codes.per.country, function(x)
  x%>%filter(Longitude>180 | Longitude<(-180))%>%
  dplyr::select(Country,Event_Code, Projects)%>%
  distinct(Country,Event_Code, Projects))


# if there are rows with wrong latitude
  if(nrow(do.call(rbind, event.codes.wrong.lon.per.country))>0){  

event.codes.wrong.lon.per.country=
  do.call(rbind, event.codes.wrong.lon.per.country)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
event.codes.wrong.lon.per.country=
lapply(sort(unique(event.codes.wrong.lon.per.country$Country)), function(x) 
  event.codes.wrong.lon.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code)%>%
  distinct(Country, Event_Code))

# name the list
names(event.codes.wrong.lon.per.country)=sapply(
  event.codes.wrong.lon.per.country, function(x) unique(x$Country))
    
# order by event code
event.codes.wrong.lon.per.country=
  lapply(event.codes.wrong.lon.per.country, function(x)
  x[order(x[,"Event_Code"]), ])

# move to da dataset with the event codes in a single row
event.codes.wrong.lon.per.country.df=
  lapply(event.codes.wrong.lon.per.country, function(x)
  data.frame(Event_Codes=paste(unique(x$Event_Code), collapse = " ")))


  event.codes.wrong.lon.per.country.df=data.frame(
    Country=names(event.codes.wrong.lon.per.country.df), 
    Event_Codes=unlist(event.codes.wrong.lon.per.country.df, use.names = F))

   event.codes.wrong.lon.per.country.df=
     event.codes.wrong.lon.per.country.df[event.codes.wrong.lon.per.country.df$Event_Codes!="",]

   #delete rownames
  rownames(event.codes.wrong.lon.per.country.df)=NULL 
   
         # subset to specific country
event.codes.wrong.lon.per.country.df=
  event.codes.wrong.lon.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(event.codes.wrong.lon.per.country.df)>0){

  
# Show the results
  
    message("No. Not all the longitude values reported are feasible These are the events with impossible longitude values
(in decimal degrees) per country.")
    
    kableExtra::kbl(event.codes.wrong.lon.per.country.df, 
                    caption = "Event codes with implausible longitude values (in decimal degrees) per country") %>%    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em")
  }}

if(!exists("event.codes.wrong.lon.per.country.df") |
    exists("event.codes.wrong.lon.per.country.df") && nrow(event.codes.wrong.lon.per.country.df)==0){  

  
   event.codes.wrong.lon.per.country=list(data.frame(Country="", Event_Code=""))
   
   rownames(event.codes.wrong.lon.per.country[[1]])<-NULL
   
    message("Yes, all the longitude values reported are feasible (in decimal degrees)")}

```
#
#
### SUMMARY ISSUES AT THE EVENT LEVEL
#
"Yes" cells indicate problems for the item specified in the corresponding column name.

```{r test, echo=FALSE, warning=FALSE, eval=T, cache=F}

#data frame event codes without start dates

event.codes.start.dates.not.provided.per.country.df=
  do.call(rbind,event.codes.start.dates.not.provided.per.country)

event.codes.start.dates.not.provided.per.country.df$No_start_date="Yes"


#data frame event codes without end dates

event.codes.end.dates.not.provided.per.country.df=
  do.call(rbind,event.codes.end.dates.not.provided.per.country)

event.codes.end.dates.not.provided.per.country.df$No_end_date="Yes"

#data frame event codes with the interpretation date before the event started

event.codes.date.interpretation.earlier.start.date.per.country.df=
  do.call(rbind, event.codes.date.interpretation.earlier.start.date.per.country)

event.codes.date.interpretation.earlier.start.date.per.country.df$interp_date_before_start="Yes"


#data frame event codes with the interpretation date before the event ended

event.codes.date.interpretation.earlier.end.date.per.country.df=
  do.call(rbind, event.codes.date.interpretation.earlier.end.date.per.country)

event.codes.date.interpretation.earlier.end.date.per.country.df$interp_date_before_end="Yes"



#data frame event codes without country 

event.codes.wo.country.per.country.df=do.call(rbind, event.codes.wo.country.per.country)

event.codes.wo.country.per.country.df$No_country="Yes"

colnames(event.codes.wo.country.per.country.df)=c("Country", "Event_Code",  "No_country")


#data frame event codes with wrong country
event.codes.bogus.country.per.country.df=
  do.call(rbind, event.codes.bogus.country.per.country)

event.codes.bogus.country.per.country.df$Wrong_country="Yes"
  


#data frame event codes wrong lat

event.codes.wrong.lat.per.country.df=
  do.call(rbind,event.codes.wrong.lat.per.country)

event.codes.wrong.lat.per.country.df$Wrong_lat="Yes"

event.codes.wrong.lat.per.country.df=event.codes.wrong.lat.per.country.df%>%
  dplyr::select(Country , Event_Code, Wrong_lat)


#data frame event codes wrong lon

event.codes.wrong.lon.per.country.df=
  do.call(rbind,event.codes.wrong.lon.per.country)

event.codes.wrong.lon.per.country.df$Wrong_lon="Yes"

event.codes.wrong.lon.per.country.df=event.codes.wrong.lon.per.country.df%>%
  dplyr::select(Country , Event_Code, Wrong_lon)



# data showing the issues per event code per country
event.codes.with.issues=full_join(event.codes.start.dates.not.provided.per.country.df, 
                                  event.codes.end.dates.not.provided.per.country.df,     
                                  by=c("Country", "Event_Code"))


event.codes.with.issues=full_join(event.codes.with.issues,
                                  event.codes.date.interpretation.earlier.start.date.per.country.df,
                                  by=c("Country", "Event_Code"))

event.codes.with.issues=full_join(event.codes.with.issues,
                                  event.codes.date.interpretation.earlier.end.date.per.country.df,
                                  by=c("Country", "Event_Code"))

event.codes.with.issues=full_join(event.codes.with.issues,
                                  event.codes.wo.country.per.country.df,
                                  by=c("Country", "Event_Code"))


event.codes.with.issues=full_join(event.codes.with.issues,
                                  event.codes.bogus.country.per.country.df, 
                                  by=c("Country", "Event_Code"))

event.codes.with.issues=full_join(event.codes.with.issues,
                                  event.codes.wrong.lat.per.country.df, 
                                  by=c("Country", "Event_Code"))

event.codes.with.issues=full_join(event.codes.with.issues,
                                  event.codes.wrong.lon.per.country.df, 
                                  by=c("Country", "Event_Code"))


event.codes.with.issues=event.codes.with.issues[order(event.codes.with.issues$Country, 
                                                      event.codes.with.issues$Event_Code),]

event.codes.with.issues=event.codes.with.issues[event.codes.with.issues$Event_Code!="",]

rownames(event.codes.with.issues)=NULL

# subset to specific country
event.codes.with.issues=
  event.codes.with.issues%>%filter(Country==params$country.of.interest)

if(nrow(event.codes.with.issues)>0){
  
      # removing columns were everything is NA
event.codes.with.issues=
event.codes.with.issues%>%dplyr::select_if(~ !all(is.na(.)))
  
  
  if(any(is.na(event.codes.with.issues))){
  event.codes.with.issues[is.na(event.codes.with.issues)]="No"}
  
message("Please scroll down the table below to see the complete dataset")  
  
 kableExtra::kbl(event.codes.with.issues,
                  caption = "Event codes with problems per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(c(2:ncol(event.codes.with.issues)), border_right = T, width = "8em")%>%

    # kableExtra::collapse_rows(1)
    scroll_box(width = "100%", height = "600px")

}else{
  
  message("No event codes present problems")}  


```

## SPECIMEN AND OBSERVATIONS 

<!-- ##### CODES  -->

<!-- ##### Are there any na's in the specimen or observation codes? -->

```{r checking spec and obs codes, echo=FALSE, warning=FALSE, cache=F, eval=F}

# Are there any na's in the specimen or observation codes

any.nas.specimen.code=any(is.na(spec$Specimen_code)) # no NAs as it should.

any.nas.observation.code=any(is.na(obs$Observation_code)) # no NAs as it should.

if(any.nas.specimen.code==T){message("There are NA specimen codes")}else{
  message("No specimen code as NA")
}

if(any.nas.observation.code==T){message("There are NA observation codes")}else{
  message("No observation code as NA")
}

```
<!-- # -->
<!-- # -->
<!-- ##### Do all specimen or observation codes start with WCS? -->
<!-- # -->

```{r checking spec and obs codes 2, echo=FALSE, warning=FALSE, cache=F, eval=F}


# Do all specimen and observation codes start with "WCS"

specimen.code.does.not.start.with.WCS=any(!grepl("WCS", spec$Specimen_code))

observation.code.does.not.start.with.WCS=any(!grepl("WCS", obs$Observation_code))


if(specimen.code.does.not.start.with.WCS==T){message("There are NA specimen codes")}else{
  message("All specimen codes start with WCS")
}

if(observation.code.does.not.start.with.WCS==T){message("There are NA specimen codes")}else{
  message("All observation codes start with WCS")
}
```

<!-- ### PROJECT TAGS -->

<!-- ##### Are the project tags reported for specimens valid? -->

```{r checking project tags specimens, echo=FALSE, warning=FALSE, cache=F, eval=F}

# ------------------- # 
# --- PROJECT TAGS ---#
# ------------------- # 

# activity project tag. A funding agency project tag will be added soon.
  
#List of valid project tags
  
valid_project_tags=c("Cambodia DTRA AIV surveillance", "Cambodia DTRA ASF surveillance",  
                     "Cambodia DTRA General Surveillance",  "Lao PDR DTRA AIV surveillance",      
                     "Lao PDR DTRA ASF surveillance", "Lao PDR DTRA Rickettsia surveillance",
                     "Lao PDR General Surveillance 2019", "Vietnam AIV surveillance 2019",       
                     "Vietnam ASF surveillance 2019", "Vietnam DTRA Rickettsia surveillance",
                     "Vietnam General Surveillance 2019")


# Specimen with wrong project tags (not present in the list above)
data.per.country.spec=data.per.country.spec[sapply(data.per.country.spec, nrow)>0]

indexes.wrong.project.tag=lapply(data.per.country.spec, function(x)
          strsplit(x$Projects, ","))


indexes.wrong.project.tag=lapply(indexes.wrong.project.tag, function(y) 
  sapply(y, function(z) all(!(z %in%valid_project_tags))))


specimen.codes.with.invalid.proj.tag.per.country=mapply(FUN = function(x,y) x[y,], data.per.country.spec, indexes.wrong.project.tag, SIMPLIFY = F)


if(nrow(do.call(rbind, specimen.codes.with.invalid.proj.tag.per.country))>0){  

  specimen.codes.with.invalid.proj.tag.per.country=
  do.call(rbind, specimen.codes.with.invalid.proj.tag.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
specimen.codes.with.invalid.proj.tag.per.country=
lapply(sort(unique(specimen.codes.with.invalid.proj.tag.per.country$Country)), function(x) 
  specimen.codes.with.invalid.proj.tag.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(specimen.codes.with.invalid.proj.tag.per.country)=sapply(
  specimen.codes.with.invalid.proj.tag.per.country, function(x) unique(x$Country))
    
# order by event code
specimen.codes.with.invalid.proj.tag.per.country=
  lapply(specimen.codes.with.invalid.proj.tag.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
specimen.codes.with.invalid.proj.tag.per.country.df=
  lapply(specimen.codes.with.invalid.proj.tag.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  specimen.codes.with.invalid.proj.tag.per.country.df=data.frame(
    Country=names(specimen.codes.with.invalid.proj.tag.per.country.df), 
    Specimen_code=unlist(specimen.codes.with.invalid.proj.tag.per.country.df, use.names = F))

   specimen.codes.with.invalid.proj.tag.per.country.df=
     specimen.codes.with.invalid.proj.tag.per.country.df[
       specimen.codes.with.invalid.proj.tag.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(specimen.codes.with.invalid.proj.tag.per.country.df)=NULL 
   
# subset to specific country
specimen.codes.with.invalid.proj.tag.per.country.df=
  specimen.codes.with.invalid.proj.tag.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(specimen.codes.with.invalid.proj.tag.per.country.df)>0){
  
  
# show the results
  

  message("No. Some specimens have an invalid project tag. These are the specimen codes with invalid project tag per country.")

  kableExtra::kbl(specimen.codes.with.invalid.proj.tag.per.country.df, 
                  caption = "Specimen codes with invalid project tag per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "10em")
}} 

if(!exists("specimen.codes.with.invalid.proj.tag.per.country.df") |
    exists("specimen.codes.with.invalid.proj.tag.per.country.df") && nrow(specimen.codes.with.invalid.proj.tag.per.country.df)==0){  

  
  specimen.codes.with.invalid.proj.tag.per.country=list(data.frame(Country="", Specimen_code=""))
   
   rownames(specimen.codes.with.invalid.proj.tag.per.country[[1]])<-NULL
  
  message("Yes, all specimens have a valid project tag")}
```
<!-- # -->
<!-- ##### Are the project tags reported for observations valid? -->
<!-- # -->
```{r checking project tags observations, echo=FALSE, warning=FALSE, cache=FALSE, eval=F}
  
# observation with wrong project tags (not present in the list above)
data.per.country.obs=data.per.country.obs[sapply(data.per.country.obs, nrow)>0]

indexes.wrong.project.tag=lapply(data.per.country.obs, function(x)
          strsplit(x$Projects, ","))


indexes.wrong.project.tag=lapply(indexes.wrong.project.tag, function(y) 
  sapply(y, function(z) all(!(z %in%valid_project_tags))))


observation.codes.with.invalid.proj.tag.per.country=mapply(FUN = function(x,y) x[y,], data.per.country.obs, indexes.wrong.project.tag, SIMPLIFY = F)


if(nrow(do.call(rbind, observation.codes.with.invalid.proj.tag.per.country))>0){  

observation.codes.with.invalid.proj.tag.per.country=
  do.call(rbind, observation.codes.with.invalid.proj.tag.per.country)%>%
  dplyr::select(Country, Observation_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
observation.codes.with.invalid.proj.tag.per.country=
lapply(sort(unique(observation.codes.with.invalid.proj.tag.per.country$Country)), function(x) 
  observation.codes.with.invalid.proj.tag.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Observation_code)%>%
  distinct(Country, Observation_code))

# name the list
names(observation.codes.with.invalid.proj.tag.per.country)=sapply(
  observation.codes.with.invalid.proj.tag.per.country, function(x) unique(x$Country))
    
# order by event code
observation.codes.with.invalid.proj.tag.per.country=
  lapply(observation.codes.with.invalid.proj.tag.per.country, function(x)
  x[order(x[,"Observation_code"]), ])

# move to da dataset with the event codes in a single row
observation.codes.with.invalid.proj.tag.per.country.df=
  lapply(observation.codes.with.invalid.proj.tag.per.country, function(x)
  data.frame(Observation_code=paste(unique(x$Observation_code), collapse = " ")))


  observation.codes.with.invalid.proj.tag.per.country.df=data.frame(
    Country=names(observation.codes.with.invalid.proj.tag.per.country.df), 
    Observation_code=unlist(observation.codes.with.invalid.proj.tag.per.country.df, use.names = F))

   observation.codes.with.invalid.proj.tag.per.country.df=
     observation.codes.with.invalid.proj.tag.per.country.df[
       observation.codes.with.invalid.proj.tag.per.country.df$Observation_code!="",]

   #delete rownames
  rownames(observation.codes.with.invalid.proj.tag.per.country.df)=NULL 
   
# subset to specific country
observation.codes.with.invalid.proj.tag.per.country.df=
  observation.codes.with.invalid.proj.tag.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(observation.codes.with.invalid.proj.tag.per.country.df)>0){
  
# show the results
  

 message("No. Some observations have an invalid project tag. These are the observation codes with invalid project tag per country.")

  
  kableExtra::kbl(observation.codes.with.invalid.proj.tag.per.country.df, 
                  caption = "Observation codes with invalid project tag per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_obs(1, bold = T, border_right = T) %>%
    kableExtra::column_obs(2, width = "10em")
}}

if(!exists("observation.codes.with.invalid.proj.tag.per.country.df") |
    exists("observation.codes.with.invalid.proj.tag.per.country.df") && nrow(observation.codes.with.invalid.proj.tag.per.country.df)==0){  

  observation.codes.with.invalid.proj.tag.per.country=list(data.frame(Country="", Observation_code=""))
   
  rownames(observation.codes.with.invalid.proj.tag.per.country[[1]])<-NULL
  
  message("Yes, all observations have a valid project tag")}

```
<!-- # -->
<!-- ##### Do specimens and observations have a single project tags?  -->
<!-- # -->
<!-- This is to check if more than one project tag assigned. The second project tag could be wrong. -->

<!-- ###### For specimens -->
```{r checking project tag unique spec, echo=FALSE, cache=FALSE, eval=F}

spec.more.than.one.project.tag.per.country=
  lapply(data.per.country.spec, function(x)
    x%>%distinct(Country, Specimen_code, Projects)%>%
      dplyr::select(Country, Specimen_code, Projects)%>%
      filter(grepl(pattern = ",", Projects))) 


if(nrow(do.call(rbind,spec.more.than.one.project.tag.per.country))>0){  
  
  spec.more.than.one.project.tag.per.country=do.call(
    rbind, spec.more.than.one.project.tag.per.country)%>%
    dplyr::select(Country, Specimen_code)
  
  
  # spit the data by country again now including the data of country based on the project tag
  # for those rows wo country
  spec.more.than.one.project.tag.per.country=
    lapply(sort(unique(spec.more.than.one.project.tag.per.country$Country)), function(x) 
      spec.more.than.one.project.tag.per.country%>%filter(Country==x)%>%
        dplyr::select(Country, Specimen_code)%>%
        distinct(Country, Specimen_code))
  
  # name the list
  names(spec.more.than.one.project.tag.per.country)=sapply(
    spec.more.than.one.project.tag.per.country, function(x) unique(x$Country))
  
  # order by specimen code
  spec.more.than.one.project.tag.per.country=
    lapply(spec.more.than.one.project.tag.per.country, function(x)
      x[order(x[,"Specimen_code"]), ])
  
  # move to da dataset with the event codes in a single row
  spec.more.than.one.project.tag.per.country.df=
    lapply(spec.more.than.one.project.tag.per.country, function(x)
      data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))
  
  
  spec.more.than.one.project.tag.per.country.df=data.frame(
    Country=names(spec.more.than.one.project.tag.per.country.df), 
    Specimen_code=unlist(spec.more.than.one.project.tag.per.country.df, use.names = F))
  
  spec.more.than.one.project.tag.per.country.df=
    spec.more.than.one.project.tag.per.country.df[
      spec.more.than.one.project.tag.per.country.df$Specimen_code!="",]
  
  #delete rownames
  rownames(spec.more.than.one.project.tag.per.country.df)=NULL 
  
           # subset to specific country
spec.more.than.one.project.tag.per.country.df=
  spec.more.than.one.project.tag.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.more.than.one.project.tag.per.country.df)>0){

  
  message("No, the data show that some specimens have more than one project tag assigned. These are the Specimen codes
that have more than one project tag assigned")
  
  kableExtra::kbl(spec.more.than.one.project.tag.per.country.df, 
                  caption = "Specimens with repeated project tags")%>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(spec.more.than.one.project.tag.per.country.df), width = "30em", border_right = T)
}} 

if(!exists("spec.more.than.one.project.tag.per.country.df") |
    exists("spec.more.than.one.project.tag.per.country.df") && nrow(spec.more.than.one.project.tag.per.country.df)==0){  

  
  spec.more.than.one.project.tag.per.country=list(data.frame(Country="", Specimen_code=""))
  
  rownames(spec.more.than.one.project.tag.per.country[[1]])<-NULL
  
  
  message("Yes, all specimens have a single project tag")}

```
<!-- # -->
<!-- ###### For observations -->
<!-- # -->
<!-- # -->
```{r checking project tag unique obs, echo=FALSE, cache=FALSE, eval=F}

obs.more.than.one.project.tag.per.country=
  lapply(data.per.country.obs, function(x)
    x%>%distinct(Country, Observation_code, Projects)%>%
      dplyr::select(Country, Observation_code, Projects)%>%
      filter(grepl(pattern = ",", Projects))) 


if(nrow(do.call(rbind,obs.more.than.one.project.tag.per.country))>0){  
  
  obs.more.than.one.project.tag.per.country=do.call(
    rbind, obs.more.than.one.project.tag.per.country)%>%
    dplyr::select(Country, Observation_code)
  
  
  # spit the data by country again now including the data of country based on the project tag
  # for those rows wo country
  obs.more.than.one.project.tag.per.country=
    lapply(sort(unique(obs.more.than.one.project.tag.per.country$Country)), function(x) 
      obs.more.than.one.project.tag.per.country%>%filter(Country==x)%>%
        dplyr::select(Country, Observation_code)%>%
        distinct(Country, Observation_code))
  
  # name the list
  names(obs.more.than.one.project.tag.per.country)=sapply(
    obs.more.than.one.project.tag.per.country, function(x) unique(x$Country))
  
  # order by obsimen code
  obs.more.than.one.project.tag.per.country=
    lapply(obs.more.than.one.project.tag.per.country, function(x)
      x[order(x[,"Observation_code"]), ])
  
  # move to da dataset with the event codes in a single row
  obs.more.than.one.project.tag.per.country.df=
    lapply(obs.more.than.one.project.tag.per.country, function(x)
      data.frame(Observation_code=paste(unique(x$Observation_code), collapse = " ")))
  
  
  obs.more.than.one.project.tag.per.country.df=data.frame(
    Country=names(obs.more.than.one.project.tag.per.country.df), 
    Observation_code=unlist(obs.more.than.one.project.tag.per.country.df, use.names = F))
  
  obs.more.than.one.project.tag.per.country.df=
    obs.more.than.one.project.tag.per.country.df[
      obs.more.than.one.project.tag.per.country.df$Observation_code!="",]
  
  #delete rownames
  rownames(obs.more.than.one.project.tag.per.country.df)=NULL 
  
# subset to specific country
obs.more.than.one.project.tag.per.country.df=
  obs.more.than.one.project.tag.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(obs.more.than.one.project.tag.per.country.df)>0){

  
  message("No, the data show that some observations have more than one project tag assigned. These are the Observations
codes that have more than one project tag assigned")
  
  kableExtra::kbl(obs.more.than.one.project.tag.per.country.df, 
                  caption = "Observations with repeated project tags")%>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(obs.more.than.one.project.tag.per.country.df), width = "30em", border_right = T)
}}

if(!exists("obs.more.than.one.project.tag.per.country.df") |
    exists("obs.more.than.one.project.tag.per.country.df") && nrow(obs.more.than.one.project.tag.per.country.df)==0){  

  
  obs.more.than.one.project.tag.per.country=list(data.frame(Country="", Observation_code=""))
  
  rownames(obs.more.than.one.project.tag.per.country[[1]])<-NULL
  
  
  message("Yes, all observations have a single project tag")}

```


<!-- ##### Does the event country match the project tag country? -->
<!-- This apply to the subset of rows where the countries are provided. -->

<!-- # -->
<!-- ###### For specimens -->
<!-- # -->
<!-- # -->
```{r checking country vs project tag ids spec, echo=FALSE, cache=FALSE, eval=F}

#subset to rows with countries provided

  spec.provided.and.correct.countries=data.per.country.spec
  spec.provided.and.correct.countries[["NA_Country"]] <- NULL
 
spec.provided.and.correct.countries=
  lapply(spec.provided.and.correct.countries, function(x)
  x%>%distinct(Country, Specimen_code, Projects)%>%
    dplyr::select(Country, Specimen_code, Projects))
  

#change Laos for Lao so this country can be found
#spec.provided.and.correct.countries$Laos[spec.provided.and.correct.countries$Laos$Country=="Laos",]$Country="Lao"


#country vector per country as list
countries.as.list.per.country=lapply(spec.provided.and.correct.countries, function(x) sapply(x$Country, list))

# projects for each row as list
projects.as.list.per.country=lapply(spec.provided.and.correct.countries, function(x)
          strsplit(x$Projects, ","))


indexes.specimen.codes.with.invalid.proj.tag.per.country=
lapply(c(1:length(countries.as.list.per.country)), function(j)
mapply(
  FUN = function(projects, countries) sapply(projects, function(x)
    sapply(x, function(y) grepl(pattern = countries, x = y), USE.NAMES = F), USE.NAMES = F),
  projects.as.list.per.country[[j]], 
  countries.as.list.per.country[[j]],
  SIMPLIFY = F))

# if false, then the project tag does not match the country
indexes.specimen.codes.with.invalid.proj.tag.per.country=
lapply(
indexes.specimen.codes.with.invalid.proj.tag.per.country, function(x)
  sapply(x, function(x) !all(x)))


# subset the rows where specimen country does not match 
spec.provided.and.correct.countries.inconsistent.project.tag=
mapply(function(x,y) x[y,], 
       spec.provided.and.correct.countries,
       indexes.specimen.codes.with.invalid.proj.tag.per.country, SIMPLIFY = F)


spec.provided.and.correct.countries.inconsistent.project.tag=lapply(
  spec.provided.and.correct.countries.inconsistent.project.tag, function(x)
    x%>%dplyr::select(Country, Specimen_code)%>%
    distinct(Country, Specimen_code))


  if(length(unlist(spec.provided.and.correct.countries.inconsistent.project.tag))>0){

    # order by Specimen code
spec.provided.and.correct.countries.inconsistent.project.tag=
  lapply(spec.provided.and.correct.countries.inconsistent.project.tag, function(x)
  x[order(x[,"Specimen_code"]), ])

  #show the specimen codes 
  spec.provided.and.correct.countries.inconsistent.project.tag.df=data.frame(
    Country=names(spec.provided.and.correct.countries.inconsistent.project.tag),
    Specimen_codes=sapply(spec.provided.and.correct.countries.inconsistent.project.tag, function(x) paste(x$Specimen_code, collapse = " ")))

  
  spec.provided.and.correct.countries.inconsistent.project.tag.df=spec.provided.and.correct.countries.inconsistent.project.tag.df[spec.provided.and.correct.countries.inconsistent.project.tag.df$Specimen_codes!="",]
  
  
  rownames(spec.provided.and.correct.countries.inconsistent.project.tag.df)=NULL 

  # subset to specific country
spec.provided.and.correct.countries.inconsistent.project.tag.df=
  spec.provided.and.correct.countries.inconsistent.project.tag.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.provided.and.correct.countries.inconsistent.project.tag.df)>0){


  message("No. Some events reporting specimens have inconsistency between the country and the country in the project tag. These are the specimen codes with inconsistency between the event country and the project tag country")
  
  kableExtra::kbl(spec.provided.and.correct.countries.inconsistent.project.tag.df, 
                  caption = "Specimen codes with inconsistent project tag country and event country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "50em")
}}
  
if(!exists("spec.provided.and.correct.countries.inconsistent.project.tag.df") |
    exists("spec.provided.and.correct.countries.inconsistent.project.tag.df") && nrow(spec.provided.and.correct.countries.inconsistent.project.tag.df)==0){  

    spec.provided.and.correct.countries.inconsistent.project.tag=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.provided.and.correct.countries.inconsistent.project.tag[[1]])<-NULL



  message("Yes, all specimens have consistent event country and project tag country")}

```
<!-- # -->
<!-- ###### For observations -->
<!-- # -->
```{r checking country vs project tag ids obs, echo=FALSE, eval=F}

#subset to rows with countries provided

  obs.provided.and.correct.countries=data.per.country.obs
  obs.provided.and.correct.countries[["NA_Country"]] <- NULL
 
obs.provided.and.correct.countries=lapply(obs.provided.and.correct.countries, function(x)
  x%>%distinct(Country, Observation_code, Projects)%>%
    dplyr::select(Country, Observation_code, Projects))
  

#change Laos for Lao so this country can be found
#obs.provided.and.correct.countries$Laos[obs.provided.and.correct.countries$Laos$Country=="Laos",]$Country="Lao"


#country vector per country as list
countries.as.list.per.country=lapply(obs.provided.and.correct.countries, function(x) sapply(x$Country, list))

# projects for each row as list
projects.as.list.per.country=lapply(obs.provided.and.correct.countries, function(x)
          strsplit(x$Projects, ","))


indexes.observation.codes.with.invalid.proj.tag.per.country=
lapply(c(1:length(countries.as.list.per.country)), function(j)
mapply(
  FUN = function(projects, countries) sapply(projects, function(x) 
    sapply(x, function(y) grepl(pattern = countries, x = y), USE.NAMES = F), USE.NAMES = F),
  projects.as.list.per.country[[j]], 
  countries.as.list.per.country[[j]],
  SIMPLIFY = F))

# if false, then the project tag does not match the country
indexes.observation.codes.with.invalid.proj.tag.per.country=
lapply(
indexes.observation.codes.with.invalid.proj.tag.per.country, function(x)
  sapply(x, function(x) !all(x)))


# subset the rows where obsimen country does not match 
obs.provided.and.correct.countries.inconsistent.project.tag=
mapply(function(x,y) x[y,], 
       obs.provided.and.correct.countries,
       indexes.observation.codes.with.invalid.proj.tag.per.country, SIMPLIFY = F)


obs.provided.and.correct.countries.inconsistent.project.tag=lapply(
  obs.provided.and.correct.countries.inconsistent.project.tag, function(x)
    x%>%dplyr::select(Country, Observation_code)%>%
    distinct(Country, Observation_code))


  if(length(unlist(obs.provided.and.correct.countries.inconsistent.project.tag))>0){

    # order by Observation code
obs.provided.and.correct.countries.inconsistent.project.tag.df=
  lapply(obs.provided.and.correct.countries.inconsistent.project.tag, function(x)
  x[order(x[,"Observation_code"]), ])

  #show the observation codes 
  obs.provided.and.correct.countries.inconsistent.project.tag.df=data.frame(
    Country=names(obs.provided.and.correct.countries.inconsistent.project.tag),
    Observation_codes=sapply(obs.provided.and.correct.countries.inconsistent.project.tag, function(x) paste(x$Observation_code, collapse = " ")))


  obs.provided.and.correct.countries.inconsistent.project.tag.df=obs.provided.and.correct.countries.inconsistent.project.tag.df[obs.provided.and.correct.countries.inconsistent.project.tag.df$Observation_codes!="",]
  
  # subset to specific country
obs.provided.and.correct.countries.inconsistent.project.tag.df=
  obs.provided.and.correct.countries.inconsistent.project.tag.df%>%filter(Country==params$country.of.interest)

if(nrow(obs.provided.and.correct.countries.inconsistent.project.tag.df)>0){
  
  
  message("No. Some events reporting observations have inconsistency between the country and the country in the project tag. These are the observation codes with inconsistency between the event country and the project tag country")
  
  kableExtra::kbl(obs.provided.and.correct.countries.inconsistent.project.tag.df, 
                  caption = "Observation codes with inconsistent project tag country and event country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "50em")
}}

if(!exists("obs.provided.and.correct.countries.inconsistent.project.tag.df") |
    exists("obs.provided.and.correct.countries.inconsistent.project.tag.df") && nrow(obs.provided.and.correct.countries.inconsistent.project.tag.df)==0){  

    obs.provided.and.correct.countries.inconsistent.project.tag=list(data.frame(Country="", Observation_code=""))
   
  rownames(obs.provided.and.correct.countries.inconsistent.project.tag[[1]])<-NULL

  message("Yes, all observations have consistent event country and project tag country")}

```

### DATES

##### Were the specimens found since the date the event started?

Date found was not mandatory until Feb 2, 2021, so several rows without this information. See below to check which specimens do not have the date found provided.

```{r specimen date , echo=FALSE, warning=FALSE, eval=T, cache=FALSE}


spec.codes.date.found.earlier.start.date.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!is.na(Date_Found))%>%
    filter(!(as.Date(Start_date)<=as.Date(Date_Found)))%>%
    dplyr::select(Country,Specimen_code)%>%
    distinct(Country, Specimen_code))



# if there are rows with wrong latitude

if(nrow(do.call(rbind, spec.codes.date.found.earlier.start.date.per.country))>0){  

  spec.codes.date.found.earlier.start.date.per.country=
  do.call(
  rbind, spec.codes.date.found.earlier.start.date.per.country)%>%
  dplyr::select(Country, Specimen_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.codes.date.found.earlier.start.date.per.country=
lapply(sort(unique(spec.codes.date.found.earlier.start.date.per.country$Country)), function(x) 
  spec.codes.date.found.earlier.start.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.codes.date.found.earlier.start.date.per.country)=sapply(
  spec.codes.date.found.earlier.start.date.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.codes.date.found.earlier.start.date.per.country=
  lapply(spec.codes.date.found.earlier.start.date.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.codes.date.found.earlier.start.date.per.country.df=
  lapply(spec.codes.date.found.earlier.start.date.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.codes.date.found.earlier.start.date.per.country.df=data.frame(
    Country=names(spec.codes.date.found.earlier.start.date.per.country.df), 
    Specimen_code=unlist(spec.codes.date.found.earlier.start.date.per.country.df, use.names = F))

   spec.codes.date.found.earlier.start.date.per.country.df=
     spec.codes.date.found.earlier.start.date.per.country.df[
       spec.codes.date.found.earlier.start.date.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.codes.date.found.earlier.start.date.per.country.df)=NULL 

  # subset to specific country
spec.codes.date.found.earlier.start.date.per.country.df=
  spec.codes.date.found.earlier.start.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.codes.date.found.earlier.start.date.per.country.df)>0){
  
  
  message("No, the data show that some specimens were found before the event started. These are the specimens that were
found earlier than the beggining of the corresponding event")
  
  kableExtra::kbl(spec.codes.date.found.earlier.start.date.per.country.df, 
                  caption = "Specimens with inconsistency between the event start date and the date they were found") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "30em")
}}
  
if(!exists("spec.codes.date.found.earlier.start.date.per.country.df") |
    exists("spec.codes.date.found.earlier.start.date.per.country.df") && nrow(spec.codes.date.found.earlier.start.date.per.country.df)==0){  


  spec.codes.date.found.earlier.start.date.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.codes.date.found.earlier.start.date.per.country[[1]])<-NULL

  
  message("Yes, all specimens were found since the corresponding event started")}
  
```
#
#
##### Were the specimens found before the event ended?
#
Date found was not mandatory until Feb 2, 2021, so several rows without this information. See below to check which specimens do not have the date found provided.
```{r specimen date 1, echo=FALSE, warning=FALSE, eval=T, cache=F}

spec.codes.date.found.earlier.end.date.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!is.na(Date_Found))%>%
    filter(!(as.Date(Date_Found) <= as.Date(End_date)))%>%
    dplyr::select(Country,Specimen_code)%>%
    distinct(Country, Specimen_code))


# if there are rows with wrong latitude



if(nrow(do.call(rbind, spec.codes.date.found.earlier.end.date.per.country))>0){  

  spec.codes.date.found.earlier.end.date.per.country=do.call(
  rbind, spec.codes.date.found.earlier.end.date.per.country)%>%
  dplyr::select(Country, Specimen_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.codes.date.found.earlier.end.date.per.country=
lapply(sort(unique(spec.codes.date.found.earlier.end.date.per.country$Country)), function(x) 
  spec.codes.date.found.earlier.end.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.codes.date.found.earlier.end.date.per.country)=sapply(
  spec.codes.date.found.earlier.end.date.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.codes.date.found.earlier.end.date.per.country=
  lapply(spec.codes.date.found.earlier.end.date.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.codes.date.found.earlier.end.date.per.country.df=
  lapply(spec.codes.date.found.earlier.end.date.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.codes.date.found.earlier.end.date.per.country.df=data.frame(
    Country=names(spec.codes.date.found.earlier.end.date.per.country.df), 
    Specimen_code=unlist(spec.codes.date.found.earlier.end.date.per.country.df, use.names = F))

   spec.codes.date.found.earlier.end.date.per.country.df=
     spec.codes.date.found.earlier.end.date.per.country.df[
       spec.codes.date.found.earlier.end.date.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.codes.date.found.earlier.end.date.per.country.df)=NULL 

  # subset to specific country
spec.codes.date.found.earlier.end.date.per.country.df=
  spec.codes.date.found.earlier.end.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.codes.date.found.earlier.end.date.per.country.df)>0){
  
  
  message("No, the data show that some specimens were found after the event ended. These are the specimens that were
found after the end of the corresponding event")
  
  kableExtra::kbl(spec.codes.date.found.earlier.end.date.per.country.df, 
                  caption = "Specimens with inconsistency between the event end date and the date they were found") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "30em")
}} 

if(!exists("spec.codes.date.found.earlier.end.date.per.country.df") |
    exists("spec.codes.date.found.earlier.end.date.per.country.df") && nrow(spec.codes.date.found.earlier.end.date.per.country.df)==0){  

  
  spec.codes.date.found.earlier.end.date.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.codes.date.found.earlier.end.date.per.country[[1]])<-NULL
  
  message("Yes, all specimens were found before the corresponding event ended")}
  
```
#
#
##### Were the specimens received since the event started?
#
Date received has been mandatory since the beginning

```{r specimen date 2, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

spec.received.before.event.started.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!(as.Date(Start_date) <= as.Date(Date_Received)))%>%
    dplyr::select(Country,Specimen_code)%>%
    distinct(Country, Specimen_code))


# if there are rows with wrong latitude

if(nrow(do.call(rbind, spec.received.before.event.started.per.country))>0){  

spec.received.before.event.started.per.country=do.call(
  rbind, spec.received.before.event.started.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.received.before.event.started.per.country=
lapply(sort(unique(spec.received.before.event.started.per.country$Country)), function(x) 
  spec.received.before.event.started.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.received.before.event.started.per.country)=sapply(
  spec.received.before.event.started.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.received.before.event.started.per.country=
  lapply(spec.received.before.event.started.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.received.before.event.started.per.country.df=
  lapply(spec.received.before.event.started.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.received.before.event.started.per.country.df=data.frame(
    Country=names(spec.received.before.event.started.per.country.df), 
    Specimen_code=unlist(spec.received.before.event.started.per.country.df, use.names = F))

   spec.received.before.event.started.per.country.df=
     spec.received.before.event.started.per.country.df[
       spec.received.before.event.started.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.received.before.event.started.per.country.df)=NULL 
  
  # subset to specific country
spec.received.before.event.started.per.country.df=
  spec.received.before.event.started.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.received.before.event.started.per.country.df)>0){
  
  
  message("No, the data show that some specimens were received before the event started. These are the specimens that were received bfore the corresponding event started")
  
  kableExtra::kbl(spec.received.before.event.started.per.country.df, 
                  caption = "Specimens with inconsistency between the event start date and the date they were received") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "30em")
}}

if(!exists("spec.received.before.event.started.per.country.df") |
    exists("spec.received.before.event.started.per.country.df") && 
   nrow(spec.received.before.event.started.per.country.df)==0){  

  
  spec.received.before.event.started.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.received.before.event.started.per.country[[1]])<-NULL
  
  message("Yes, all specimens were received after the corresponding event started")}
  
```
#
#
##### Were the specimens received since the date they were found?
#
```{r specimen date 3, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

spec.received.earlier.than.found.date.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!is.na(Date_Found))%>%
    filter(!(as.Date(Date_Received) >= as.Date(Date_Found)))%>%
    dplyr::select(Country,Specimen_code)%>%
    distinct(Country, Specimen_code))


# if there are rows with wrong latitude

if(nrow(do.call(rbind, spec.received.earlier.than.found.date.per.country))>0){  

spec.received.earlier.than.found.date.per.country=do.call(
  rbind, spec.received.earlier.than.found.date.per.country)%>%
  dplyr::select(Country, Specimen_code)



# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.received.earlier.than.found.date.per.country=
lapply(sort(unique(spec.received.earlier.than.found.date.per.country$Country)), function(x) 
  spec.received.earlier.than.found.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.received.earlier.than.found.date.per.country)=sapply(
  spec.received.earlier.than.found.date.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.received.earlier.than.found.date.per.country=
  lapply(spec.received.earlier.than.found.date.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.received.earlier.than.found.date.per.country.df=
  lapply(spec.received.earlier.than.found.date.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.received.earlier.than.found.date.per.country.df=data.frame(
    Country=names(spec.received.earlier.than.found.date.per.country.df), 
    Specimen_code=unlist(spec.received.earlier.than.found.date.per.country.df, use.names = F))

   spec.received.earlier.than.found.date.per.country.df=
     spec.received.earlier.than.found.date.per.country.df[
       spec.received.earlier.than.found.date.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.received.earlier.than.found.date.per.country.df)=NULL 

  # subset to specific country
spec.received.earlier.than.found.date.per.country.df=
  spec.received.earlier.than.found.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.received.earlier.than.found.date.per.country.df)>0){
  
  
  message("No, the data show that some specimens were received before they were found. These are the specimens that were found before they were received")
  
  kableExtra::kbl(spec.received.earlier.than.found.date.per.country.df, 
                  caption = "Specimens with inconsistency between the the date they were received and the date they were found") %>%    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "30em")
}}
  
if(!exists("spec.received.earlier.than.found.date.per.country.df") |
    exists("spec.received.earlier.than.found.date.per.country.df") && 
   nrow(spec.received.earlier.than.found.date.per.country.df)==0){  

  spec.received.earlier.than.found.date.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.received.earlier.than.found.date.per.country[[1]])<-NULL
  

  message("Yes, all specimens were received after they were found")}
  
```
#
#
##### Were necropsies conducted after the event started?
#
```{r specimen date 4, echo=FALSE, warning=FALSE, eval=T, cache=F}

spec.date.necropsy.earlier.than.start.date.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!is.na(Date_Found))%>%
    filter(!(as.Date(Necropsy_date) >= as.Date(Start_date)))%>%
    dplyr::select(Country,Specimen_code)%>%
    distinct(Country, Specimen_code))


# if there are rows with wrong latitude


if(nrow(do.call(rbind, spec.date.necropsy.earlier.than.start.date.per.country))>0){  

spec.date.necropsy.earlier.than.start.date.per.country=do.call(
  rbind, spec.date.necropsy.earlier.than.start.date.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.date.necropsy.earlier.than.start.date.per.country=
lapply(sort(unique(spec.date.necropsy.earlier.than.start.date.per.country$Country)), function(x) 
  spec.date.necropsy.earlier.than.start.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.date.necropsy.earlier.than.start.date.per.country)=sapply(
  spec.date.necropsy.earlier.than.start.date.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.date.necropsy.earlier.than.start.date.per.country=
  lapply(spec.date.necropsy.earlier.than.start.date.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.date.necropsy.earlier.than.start.date.per.country.df=
  lapply(spec.date.necropsy.earlier.than.start.date.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.date.necropsy.earlier.than.start.date.per.country.df=data.frame(
    Country=names(spec.date.necropsy.earlier.than.start.date.per.country.df), 
    Specimen_code=unlist(spec.date.necropsy.earlier.than.start.date.per.country.df, use.names = F))

   spec.date.necropsy.earlier.than.start.date.per.country.df=
     spec.date.necropsy.earlier.than.start.date.per.country.df[
       spec.date.necropsy.earlier.than.start.date.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.date.necropsy.earlier.than.start.date.per.country.df)=NULL 

  # subset to specific country
spec.date.necropsy.earlier.than.start.date.per.country.df=
  spec.date.necropsy.earlier.than.start.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.date.necropsy.earlier.than.start.date.per.country.df)>0){
  
  
  message("No. Not all necropsies were conducted since the corresponding events started. 
           These are the specimens with inconsistency between the necropsy date and the date the event started")
  
  kableExtra::kbl(spec.date.necropsy.earlier.than.start.date.per.country.df, 
                  caption = "Specimens with inconsistent necropsy date and the date the corresponding event started") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "30em")
}}

if(!exists("spec.date.necropsy.earlier.than.start.date.per.country.df") |
    exists("spec.date.necropsy.earlier.than.start.date.per.country.df") && 
   nrow(spec.date.necropsy.earlier.than.start.date.per.country.df)==0){  

  spec.date.necropsy.earlier.than.start.date.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.date.necropsy.earlier.than.start.date.per.country[[1]])<-NULL
 
  message("Yes, all specimens have consistent necropsy date and date event started")}

```
#
#
##### Were necropsies conducted since the specimen was found?
#
Date found is not mandatory so several rows without this information

```{r specimen date 5, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

spec.date.necropsy.earlier.than.date.found.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!is.na(Date_Found))%>%
    filter(!(as.Date(Necropsy_date) >= as.Date(Date_Found)))%>%
    dplyr::select(Country,Specimen_code)%>%
    distinct(Country, Specimen_code))


# if there are rows with wrong latitude

if(nrow(do.call(rbind, spec.date.necropsy.earlier.than.date.found.per.country))>0){  

spec.date.necropsy.earlier.than.date.found.per.country=do.call(
  rbind, spec.date.necropsy.earlier.than.date.found.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.date.necropsy.earlier.than.date.found.per.country=
lapply(sort(unique(spec.date.necropsy.earlier.than.date.found.per.country$Country)), function(x) 
  spec.date.necropsy.earlier.than.date.found.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.date.necropsy.earlier.than.date.found.per.country)=sapply(
  spec.date.necropsy.earlier.than.date.found.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.date.necropsy.earlier.than.date.found.per.country=
  lapply(spec.date.necropsy.earlier.than.date.found.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.date.necropsy.earlier.than.date.found.per.country.df=
  lapply(spec.date.necropsy.earlier.than.date.found.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.date.necropsy.earlier.than.date.found.per.country.df=data.frame(
    Country=names(spec.date.necropsy.earlier.than.date.found.per.country.df), 
    Specimen_code=unlist(spec.date.necropsy.earlier.than.date.found.per.country.df, use.names = F))

   spec.date.necropsy.earlier.than.date.found.per.country.df=
     spec.date.necropsy.earlier.than.date.found.per.country.df[
       spec.date.necropsy.earlier.than.date.found.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.date.necropsy.earlier.than.date.found.per.country.df)=NULL 

  # subset to specific country
spec.date.necropsy.earlier.than.date.found.per.country.df=
  spec.date.necropsy.earlier.than.date.found.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.date.necropsy.earlier.than.date.found.per.country.df)>0){
  
  
message("No. Not all necropsies were conducted since the corresponding specimen was found. 
           These are the specimens with inconsistency between the necropsy date and the date they were found")
 
  
  kableExtra::kbl(spec.date.necropsy.earlier.than.date.found.per.country.df, 
                  caption = "Specimens with inconsistent necropsy date and the date they were found") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "10em")
}}

if(!exists("spec.date.necropsy.earlier.than.date.found.per.country.df") |
    exists("spec.date.necropsy.earlier.than.date.found.per.country.df") && 
   nrow(spec.date.necropsy.earlier.than.date.found.per.country.df)==0){  

  
   spec.date.necropsy.earlier.than.date.found.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.date.necropsy.earlier.than.date.found.per.country[[1]])<-NULL
  
  message("Yes, all specimens have consistent necropsy date and the date they were found")}

```
#
#
##### Were necropsies conducted after the specimen was received?
#
```{r specimen date 6, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

spec.date.necropsy.earlier.than.date.received.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!(as.Date(Necropsy_date) >= as.Date(Date_Received)))%>%
    dplyr::select(Country,Specimen_code)%>%
    distinct(Country, Specimen_code))


# if there are rows with wrong latitude
if(nrow(do.call(rbind, spec.date.necropsy.earlier.than.date.received.per.country))>0){  

spec.date.necropsy.earlier.than.date.received.per.country=do.call(
  rbind, spec.date.necropsy.earlier.than.date.received.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.date.necropsy.earlier.than.date.received.per.country=
lapply(sort(unique(spec.date.necropsy.earlier.than.date.received.per.country$Country)), function(x) 
  spec.date.necropsy.earlier.than.date.received.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.date.necropsy.earlier.than.date.received.per.country)=sapply(
  spec.date.necropsy.earlier.than.date.received.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.date.necropsy.earlier.than.date.received.per.country=
  lapply(spec.date.necropsy.earlier.than.date.received.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.date.necropsy.earlier.than.date.received.per.country.df=
  lapply(spec.date.necropsy.earlier.than.date.received.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.date.necropsy.earlier.than.date.received.per.country.df=data.frame(
    Country=names(spec.date.necropsy.earlier.than.date.received.per.country.df), 
    Specimen_code=unlist(spec.date.necropsy.earlier.than.date.received.per.country.df, use.names = F))

   spec.date.necropsy.earlier.than.date.received.per.country.df=
     spec.date.necropsy.earlier.than.date.received.per.country.df[
       spec.date.necropsy.earlier.than.date.received.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.date.necropsy.earlier.than.date.received.per.country.df)=NULL 

  # subset to specific country
spec.date.necropsy.earlier.than.date.received.per.country.df=
  spec.date.necropsy.earlier.than.date.received.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.date.necropsy.earlier.than.date.received.per.country.df)>0){
  
  
message("No. Not all necropsies were conducted since the corresponding specimen was received 
           These are the specimens with inconsistency between the necropsy date and the date they were received")
 
  
  kableExtra::kbl(spec.date.necropsy.earlier.than.date.received.per.country.df, 
                  caption = "Specimens with inconsistent necropsy date and the date received") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2,  border_right = T, width = "10em")
}}

if(!exists("spec.date.necropsy.earlier.than.date.received.per.country.df") |
    exists("spec.date.necropsy.earlier.than.date.received.per.country.df") && 
   nrow(spec.date.necropsy.earlier.than.date.received.per.country.df)==0){  

  
  spec.date.necropsy.earlier.than.date.received.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.date.necropsy.earlier.than.date.received.per.country[[1]])<-NULL
  
  message("Yes, all specimens have consistent necropsy date and date received")}

```
#
##### Were the observations observed since the event started?
#
#
```{r observation date, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

obs.codes.date.found.earlier.start.date.per.country=
  lapply(data.per.country.obs, function(x)
  x%>%
    filter(!(as.Date(Start_date)<=as.Date(Observation_date)))%>%
    dplyr::select(Country, Observation_code, Projects)%>%
    distinct(Country, Observation_code, Projects))



# if there are rows with wrong latitude

if(nrow(do.call(rbind,obs.codes.date.found.earlier.start.date.per.country))>0){  

obs.codes.date.found.earlier.start.date.per.country=do.call(
  rbind, obs.codes.date.found.earlier.start.date.per.country)%>%
  dplyr::select(Country, Observation_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
obs.codes.date.found.earlier.start.date.per.country=
lapply(sort(unique(obs.codes.date.found.earlier.start.date.per.country$Country)), function(x) 
  obs.codes.date.found.earlier.start.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Observation_code)%>%
  distinct(Country, Observation_code))

# name the list
names(obs.codes.date.found.earlier.start.date.per.country)=sapply(
  obs.codes.date.found.earlier.start.date.per.country, function(x) unique(x$Country))
    
# order by specimen code
obs.codes.date.found.earlier.start.date.per.country=
  lapply(obs.codes.date.found.earlier.start.date.per.country, function(x)
  x[order(x[,"Observation_code"]), ])

# move to da dataset with the event codes in a single row
obs.codes.date.found.earlier.start.date.per.country.df=
  lapply(obs.codes.date.found.earlier.start.date.per.country, function(x)
  data.frame(Observation_code=paste(unique(x$Observation_code), collapse = " ")))


  obs.codes.date.found.earlier.start.date.per.country.df=data.frame(
    Country=names(obs.codes.date.found.earlier.start.date.per.country.df), 
    Observation_code=unlist(obs.codes.date.found.earlier.start.date.per.country.df, use.names = F))

   obs.codes.date.found.earlier.start.date.per.country.df=
     obs.codes.date.found.earlier.start.date.per.country.df[
       obs.codes.date.found.earlier.start.date.per.country.df$Observation_code!="",]

   #delete rownames
  rownames(obs.codes.date.found.earlier.start.date.per.country.df)=NULL 

  # subset to specific country
obs.codes.date.found.earlier.start.date.per.country.df=
  obs.codes.date.found.earlier.start.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(obs.codes.date.found.earlier.start.date.per.country.df)>0){
  
  
  message("No, the data show that some observations were observed before the event started. These are the observations
that were observed earlier than the beggining of the corresponding event")
  
  kableExtra::kbl(obs.codes.date.found.earlier.start.date.per.country.df, 
                  caption = "Observations with inconsistency between the event start date and the date they were observed")%>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em", border_right = T)
}}

if(!exists("obs.codes.date.found.earlier.start.date.per.country.df") |
    exists("obs.codes.date.found.earlier.start.date.per.country.df") && 
   nrow(obs.codes.date.found.earlier.start.date.per.country.df)==0){  

  
  obs.codes.date.found.earlier.start.date.per.country=list(data.frame(Country="", Observation_code=""))
   
  rownames(obs.codes.date.found.earlier.start.date.per.country[[1]])<-NULL

  
  message("Yes, all observations were found since the corresponding event started")}
  
```

##### Were the observations observed before the event ended?

```{r observation date 2, echo=FALSE, warning=FALSE, eval=T, cache=F}

obs.codes.date.found.earlier.end.date.per.country=
  lapply(data.per.country.obs, function(x)
  x%>%
    filter(!(as.Date(Observation_date)<=as.Date(End_date)))%>%
    dplyr::select(Country, Observation_code, Projects)%>%
    distinct(Country, Observation_code, Projects))



# if there are rows with wrong latitude
if(nrow(do.call(rbind, obs.codes.date.found.earlier.end.date.per.country))>0){  

obs.codes.date.found.earlier.end.date.per.country=do.call(
  rbind, obs.codes.date.found.earlier.end.date.per.country)%>%
  dplyr::select(Country, Observation_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
obs.codes.date.found.earlier.end.date.per.country=
lapply(sort(unique(obs.codes.date.found.earlier.end.date.per.country$Country)), function(x) 
  obs.codes.date.found.earlier.end.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Observation_code)%>%
  distinct(Country, Observation_code))

# name the list
names(obs.codes.date.found.earlier.end.date.per.country)=sapply(
  obs.codes.date.found.earlier.end.date.per.country, function(x) unique(x$Country))
    
# order by specimen code
obs.codes.date.found.earlier.end.date.per.country=
  lapply(obs.codes.date.found.earlier.end.date.per.country, function(x)
  x[order(x[,"Observation_code"]), ])

# move to da dataset with the event codes in a single row
obs.codes.date.found.earlier.end.date.per.country.df=
  lapply(obs.codes.date.found.earlier.end.date.per.country, function(x)
  data.frame(Observation_code=paste(unique(x$Observation_code), collapse = " ")))


  obs.codes.date.found.earlier.end.date.per.country.df=data.frame(
    Country=names(obs.codes.date.found.earlier.end.date.per.country.df), 
    Observation_code=unlist(obs.codes.date.found.earlier.end.date.per.country.df, use.names = F))

   obs.codes.date.found.earlier.end.date.per.country.df=
     obs.codes.date.found.earlier.end.date.per.country.df[
       obs.codes.date.found.earlier.end.date.per.country.df$Observation_code!="",]

   #delete rownames
  rownames(obs.codes.date.found.earlier.end.date.per.country.df)=NULL 

    # subset to specific country
obs.codes.date.found.earlier.end.date.per.country.df=
  obs.codes.date.found.earlier.end.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(obs.codes.date.found.earlier.end.date.per.country.df)>0){


  message("No, the data show that some observations were observed after the event ended. These are the observations that were found after the end of the corresponding event")
  
  kableExtra::kbl(obs.codes.date.found.earlier.end.date.per.country.df, 
                caption = "Observations with inconsistency between the event end date and the date they were observed") %>%

    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em", border_right = T)
}}
  
if(!exists("obs.codes.date.found.earlier.end.date.per.country.df") |
    exists("obs.codes.date.found.earlier.end.date.per.country.df") && 
   nrow(obs.codes.date.found.earlier.end.date.per.country.df)==0){  

   
  obs.codes.date.found.earlier.end.date.per.country=list(data.frame(Country="", Observation_code=""))
   
  rownames(obs.codes.date.found.earlier.end.date.per.country[[1]])<-NULL

  message("Yes, all observations were observed before the corresponding event ended")}
    
  
```

### OBSERVED NUMBERS 

##### Is there at least one individual reported per observation?

```{r observation at least one, echo=FALSE, warning=FALSE, eval=T}

total.obs.healthy.sick.dead=
  
 lapply(data.per.country.obs, function(x)
  x%>%

    dplyr::select(Country, Observation_code, 
                  observation_number_observed,
                  observation_number_healthy,
                  observation_number_sick,
                  observation_number_dead)%>%

         mutate(obs.healthy.sick.dead =rowSums(select(., all_of(c("observation_number_observed", cols.num[-1])))))%>%
    dplyr::select(Country, Observation_code, obs.healthy.sick.dead))


total.obs.healthy.sick.dead.per.country=
 lapply(total.obs.healthy.sick.dead, function(x)
   x%>%filter(obs.healthy.sick.dead==0))


if(nrow(do.call(rbind, total.obs.healthy.sick.dead.per.country))>0){  

  total.obs.healthy.sick.dead.per.country=
  do.call(
  rbind, total.obs.healthy.sick.dead.per.country)%>%
  dplyr::select(Country, Observation_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
total.obs.healthy.sick.dead.per.country=
lapply(sort(unique(total.obs.healthy.sick.dead.per.country$Country)), function(x) 
  total.obs.healthy.sick.dead.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Observation_code)%>%
  distinct(Country, Observation_code))

# name the list
names(total.obs.healthy.sick.dead.per.country)=sapply(
  total.obs.healthy.sick.dead.per.country, function(x) unique(x$Country))
    
# order by specimen code
total.obs.healthy.sick.dead.per.country=
  lapply(total.obs.healthy.sick.dead.per.country, function(x)
  x[order(x[,"Observation_code"]), ])

# move to da dataset with the observation codes in a single row
total.obs.healthy.sick.dead.per.country.df=
  lapply(total.obs.healthy.sick.dead.per.country, function(x)
  data.frame(Observation_code=paste(unique(x$Observation_code), collapse = " ")))


  total.obs.healthy.sick.dead.per.country.df=data.frame(
    Country=names(total.obs.healthy.sick.dead.per.country.df), 
    Observation_code=unlist(total.obs.healthy.sick.dead.per.country.df, use.names = F))

   total.obs.healthy.sick.dead.per.country.df=
     total.obs.healthy.sick.dead.per.country.df[
       total.obs.healthy.sick.dead.per.country.df$Observation_code!="",]

   #delete rownames
  rownames(total.obs.healthy.sick.dead.per.country.df)=NULL 

      # subset to specific country
total.obs.healthy.sick.dead.per.country.df=
  total.obs.healthy.sick.dead.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(total.obs.healthy.sick.dead.per.country.df)>0){


  message("No. Not all observations have at least one individual reported. These are the observations without animals")
  
  kableExtra::kbl(total.obs.healthy.sick.dead.per.country.df, 
                      caption = "Observations without individuals per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em")
  # print(specimen.codes.with.animal.ids.as.na.per.country)
}
}

if(!exists("total.obs.healthy.sick.dead.per.country.df") |
    exists("total.obs.healthy.sick.dead.per.country.df") && 
   nrow(total.obs.healthy.sick.dead.per.country.df)==0){  

    
    total.obs.healthy.sick.dead.per.country=list(data.frame(Country="", Observation_code=""))
   
  rownames(total.obs.healthy.sick.dead.per.country[[1]])<-NULL
    
    message("Yes, all observations have at least one individual")}



```

##### Does total seen match the sum of number healthy, number sick, and number dead?

```{r observation number, echo=FALSE, warning=FALSE, eval=T}

obs.healthy.sick.dead.equal.observed.sum=
  
 lapply(data.per.country.obs, function(x)
  x%>%

    dplyr::select(Country, Observation_code, 
                  observation_number_observed,
                  observation_number_healthy,
                  observation_number_sick,
                  observation_number_dead)%>%

         mutate(healthy.sick.dead =rowSums(select(., all_of(cols.num[-1])))))


obs.healthy.sick.dead.equal.observed.sum.per.country=
lapply(obs.healthy.sick.dead.equal.observed.sum, function(x)
        x%>%
        filter(healthy.sick.dead!=observation_number_observed)%>%
        dplyr::select(Country, Observation_code))


if(nrow(do.call(rbind, obs.healthy.sick.dead.equal.observed.sum.per.country))>0){  

  obs.healthy.sick.dead.equal.observed.sum.per.country=
  do.call(
  rbind, obs.healthy.sick.dead.equal.observed.sum.per.country)%>%
  dplyr::select(Country, Observation_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
obs.healthy.sick.dead.equal.observed.sum.per.country=
lapply(sort(unique(obs.healthy.sick.dead.equal.observed.sum.per.country$Country)), function(x) 
  obs.healthy.sick.dead.equal.observed.sum.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Observation_code)%>%
  distinct(Country, Observation_code))

# name the list
names(obs.healthy.sick.dead.equal.observed.sum.per.country)=sapply(
  obs.healthy.sick.dead.equal.observed.sum.per.country, function(x) unique(x$Country))
    
# order by specimen code
obs.healthy.sick.dead.equal.observed.sum.per.country=
  lapply(obs.healthy.sick.dead.equal.observed.sum.per.country, function(x)
  x[order(x[,"Observation_code"]), ])

# move to da dataset with the observation codes in a single row
obs.healthy.sick.dead.equal.observed.sum.per.country.df=
  lapply(obs.healthy.sick.dead.equal.observed.sum.per.country, function(x)
  data.frame(Observation_code=paste(unique(x$Observation_code), collapse = " ")))


  obs.healthy.sick.dead.equal.observed.sum.per.country.df=data.frame(
    Country=names(obs.healthy.sick.dead.equal.observed.sum.per.country.df), 
    Observation_code=unlist(obs.healthy.sick.dead.equal.observed.sum.per.country.df, use.names = F))

   obs.healthy.sick.dead.equal.observed.sum.per.country.df=
     obs.healthy.sick.dead.equal.observed.sum.per.country.df[
       obs.healthy.sick.dead.equal.observed.sum.per.country.df$Observation_code!="",]

   #delete rownames
  rownames(obs.healthy.sick.dead.equal.observed.sum.per.country.df)=NULL 

      # subset to specific country
obs.healthy.sick.dead.equal.observed.sum.per.country.df=
  obs.healthy.sick.dead.equal.observed.sum.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(obs.healthy.sick.dead.equal.observed.sum.per.country.df)>0){


  message("No. Not all total observed and the sum of the number of healthy, sick, and dead observed individuals match. These are the observations with values that do not match per country")
  
  kableExtra::kbl(obs.healthy.sick.dead.equal.observed.sum.per.country.df, 
                      caption = "Observations with incongruent numbers of individuals per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em")
  # print(specimen.codes.with.animal.ids.as.na.per.country)
}
}

if(!exists("obs.healthy.sick.dead.equal.observed.sum.per.country.df") |
    exists("obs.healthy.sick.dead.equal.observed.sum.per.country.df") && 
   nrow(obs.healthy.sick.dead.equal.observed.sum.per.country.df)==0){  

    
    obs.healthy.sick.dead.equal.observed.sum.per.country=list(data.frame(Country="", Observation_code=""))
   
  rownames(obs.healthy.sick.dead.equal.observed.sum.per.country[[1]])<-NULL
    
    message("Yes, all observations have correct consistent numbers")}


```

### ANIMAL IDS

##### Are all animal IDs provided?

```{r checking animal ids, echo=FALSE, cache=FALSE, eval=T}


specimen.codes.with.animal.ids.as.na.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(is.na(Animal_ID))%>%
    dplyr::select(Country, Specimen_code)%>%
    distinct(Country, Specimen_code))


if(nrow(do.call(rbind, specimen.codes.with.animal.ids.as.na.per.country))>0){  

  specimen.codes.with.animal.ids.as.na.per.country=
  do.call(
  rbind, specimen.codes.with.animal.ids.as.na.per.country)%>%
  dplyr::select(Country, Specimen_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
specimen.codes.with.animal.ids.as.na.per.country=
lapply(sort(unique(specimen.codes.with.animal.ids.as.na.per.country$Country)), function(x) 
  specimen.codes.with.animal.ids.as.na.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(specimen.codes.with.animal.ids.as.na.per.country)=sapply(
  specimen.codes.with.animal.ids.as.na.per.country, function(x) unique(x$Country))
    
# order by specimen code
specimen.codes.with.animal.ids.as.na.per.country=
  lapply(specimen.codes.with.animal.ids.as.na.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
specimen.codes.with.animal.ids.as.na.per.country.df=
  lapply(specimen.codes.with.animal.ids.as.na.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  specimen.codes.with.animal.ids.as.na.per.country.df=data.frame(
    Country=names(specimen.codes.with.animal.ids.as.na.per.country.df), 
    Specimen_code=unlist(specimen.codes.with.animal.ids.as.na.per.country.df, use.names = F))

   specimen.codes.with.animal.ids.as.na.per.country.df=
     specimen.codes.with.animal.ids.as.na.per.country.df[
       specimen.codes.with.animal.ids.as.na.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(specimen.codes.with.animal.ids.as.na.per.country.df)=NULL 

      # subset to specific country
specimen.codes.with.animal.ids.as.na.per.country.df=
  specimen.codes.with.animal.ids.as.na.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(specimen.codes.with.animal.ids.as.na.per.country.df)>0){


  message("No. Not all animal IDs are provided. These are the specimens whose animal IDs are NA per country")
  
  kableExtra::kbl(specimen.codes.with.animal.ids.as.na.per.country.df, 
                      caption = "Specimens with no Animal IDs per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em")
  # print(specimen.codes.with.animal.ids.as.na.per.country)
}}

if(!exists("specimen.codes.with.animal.ids.as.na.per.country.df") |
    exists("specimen.codes.with.animal.ids.as.na.per.country.df") && 
   nrow(specimen.codes.with.animal.ids.as.na.per.country.df)==0){  

    
    specimen.codes.with.animal.ids.as.na.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(specimen.codes.with.animal.ids.as.na.per.country[[1]])<-NULL
    
    message("Yes, all animal IDs are provided")}

```
<!-- # -->
<!-- # -->
<!-- ##### Do the Animal IDs follow the standardized labeling structure? -->
<!-- # -->

```{r checking animal ids 2, echo=FALSE, warning=FALSE, cache=FALSE, eval=F}

# Structure of animal IDs follow the standardized frame
country.abbreviations=c("KH", "LA", "VN")

project.abbreviations=c("W")

taxa=list(A="Amphibian", B="Bat", C="Carnivore",
          E="Elephant", F="Fish", G="Pangolin",
          L="Reptile", M="Marine mammal", P="Primate",
          R="Rodent", S="Swine", U="Ungulate",
          W="Wild bird", X="Environmental")

project.country.abbreviations=paste0(rep(project.abbreviations,
                                         each = length(country.abbreviations))
                                     , country.abbreviations, "-")

# first part of animal ids when they are not NA
first.part.animal.ids.project.country.hyphen= # one letter for project, 2 letters for country, and hyphen
  substr(spec[!is.na(spec$Animal_ID),]$Animal_ID, 1,4) 



# in the first part of the label
first.part.animal.ids.is.correct=all(
  
  substring(first.part.animal.ids.project.country.hyphen, 1,1)%in%project.abbreviations & # first piece does have a valid project letter?
    
    substring(first.part.animal.ids.project.country.hyphen, 2,3)%in%country.abbreviations & # second piece has valid country abbreviations?
    
    substring(first.part.animal.ids.project.country.hyphen, 4)=="-") # third piece is a hyphen? 



#in the second part of the label
second.part.animal.ids.taxa.numeric=  # one letter for taxa, 3 numbers
  sapply(strsplit(spec[!is.na(spec$Animal_ID),]$Animal_ID, "-"), function(x) x[2])


#id second part of the animal id structure
second.part.animal.ids.is.correct=all(
  
  substring(second.part.animal.ids.taxa.numeric, 1,1)%in%names(taxa) & # first piece does have a valid taxa letter?
    
    !is.na(as.numeric(substring(second.part.animal.ids.taxa.numeric, 2,4)))) # second piece: cgaracters 2 to 4 can be moved to a number


wrong.animal.id.first.part=
  
  spec[!is.na(spec$Animal_ID),]$Animal_ID[
    
    !(substring(first.part.animal.ids.project.country.hyphen, 1,1)%in%project.abbreviations) | # first piece does have a valid project letter?
      
      !(substring(first.part.animal.ids.project.country.hyphen, 2,3)%in%country.abbreviations) | # second piece has valid country abbreviations?
      
      substring(first.part.animal.ids.project.country.hyphen, 4)!="-"]
  
  
wrong.animal.id.second.part=
  
  spec[!is.na(spec$Animal_ID),]$Animal_ID[
    
    !(substring(second.part.animal.ids.taxa.numeric, 1,1)%in%names(taxa)) | # first piece does have a valid taxa letter?
      
      is.na(as.numeric(substring(second.part.animal.ids.taxa.numeric, 2,4)))]
  
  
wrong.animal.id=sort(unique(wrong.animal.id.first.part, wrong.animal.id.second.part))
  
 
specimen.codes.with.wrong.animal.ids.per.country=
lapply(data.per.country.spec, function(x)
x%>%
  filter(!is.na(Animal_ID) & Animal_ID%in%wrong.animal.id)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

  
if(nrow(do.call(rbind, specimen.codes.with.wrong.animal.ids.per.country))>0){  

  specimen.codes.with.wrong.animal.ids.per.country=
  do.call(
  rbind, specimen.codes.with.wrong.animal.ids.per.country)%>%
  dplyr::select(Country, Specimen_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
specimen.codes.with.wrong.animal.ids.per.country=
lapply(sort(unique(specimen.codes.with.wrong.animal.ids.per.country$Country)), function(x) 
  specimen.codes.with.wrong.animal.ids.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(specimen.codes.with.wrong.animal.ids.per.country)=sapply(
  specimen.codes.with.wrong.animal.ids.per.country, function(x) unique(x$Country))
    
# order by specimen code
specimen.codes.with.wrong.animal.ids.per.country=
  lapply(specimen.codes.with.wrong.animal.ids.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
specimen.codes.with.wrong.animal.ids.per.country.df=
  lapply(specimen.codes.with.wrong.animal.ids.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  specimen.codes.with.wrong.animal.ids.per.country.df=data.frame(
    Country=names(specimen.codes.with.wrong.animal.ids.per.country.df), 
    Specimen_code=unlist(specimen.codes.with.wrong.animal.ids.per.country.df, use.names = F))

   specimen.codes.with.wrong.animal.ids.per.country.df=
     specimen.codes.with.wrong.animal.ids.per.country.df[
       specimen.codes.with.wrong.animal.ids.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(specimen.codes.with.wrong.animal.ids.per.country.df)=NULL
  
        # subset to specific country
specimen.codes.with.wrong.animal.ids.per.country.df=
  specimen.codes.with.wrong.animal.ids.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(specimen.codes.with.wrong.animal.ids.per.country.df)>0){

  
    message("No. Not all animal IDs provided follow the label format. These are the animal IDs with wrong format. Please
scroll the table below down and left-right to see the complete dataset if needed", appendLF = T)
    
  kableExtra::kbl(specimen.codes.with.wrong.animal.ids.per.country.df, 
                  caption = "Specimen codes with wrong Animal IDs per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em")

}}

if(!exists("specimen.codes.with.wrong.animal.ids.per.country.df") |
    exists("specimen.codes.with.wrong.animal.ids.per.country.df") && 
   nrow(specimen.codes.with.wrong.animal.ids.per.country.df)==0){  

  specimen.codes.with.wrong.animal.ids.per.country=list(data.frame(Country="", Observation_code=""))
   
  rownames(specimen.codes.with.wrong.animal.ids.per.country[[1]])<-NULL
    
    
  message("Yes, all animal IDs provided have the correct format")}

```
#
#
##### Are Animal Ids unique for each Specimen Code?
#
```{r checking animal ids 3, echo=FALSE, warning=FALSE, cache=FALSE, eval=T}

# each specimen code has a single animal id?

specimen.codes.with.more.than.one.animal.ids.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
  filter(!is.na(Animal_ID))%>%
  distinct(Specimen_code, Animal_ID, Country)%>%
  dplyr::count(Country, Specimen_code, Animal_ID) %>% 
  filter(n>1)%>%
  dplyr::select(Country, Specimen_code))

  
if(nrow(do.call(rbind, specimen.codes.with.more.than.one.animal.ids.per.country))>0){  

  
  specimen.codes.with.more.than.one.animal.ids.per.country=
  do.call(
  rbind, specimen.codes.with.more.than.one.animal.ids.per.country)%>%
  dplyr::select(Country, Specimen_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
specimen.codes.with.more.than.one.animal.ids.per.country=
lapply(sort(unique(specimen.codes.with.more.than.one.animal.ids.per.country$Country)), function(x) 
  specimen.codes.with.more.than.one.animal.ids.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(specimen.codes.with.more.than.one.animal.ids.per.country)=sapply(
  specimen.codes.with.more.than.one.animal.ids.per.country, function(x) unique(x$Country))
    
# order by specimen code
specimen.codes.with.more.than.one.animal.ids.per.country=
  lapply(specimen.codes.with.more.than.one.animal.ids.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
specimen.codes.with.more.than.one.animal.ids.per.country.df=
  lapply(specimen.codes.with.more.than.one.animal.ids.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  specimen.codes.with.more.than.one.animal.ids.per.country.df=data.frame(
    Country=names(specimen.codes.with.more.than.one.animal.ids.per.country.df), 
    Specimen_code=unlist(specimen.codes.with.more.than.one.animal.ids.per.country.df, use.names = F))

   specimen.codes.with.more.than.one.animal.ids.per.country.df=
     specimen.codes.with.more.than.one.animal.ids.per.country.df[
       specimen.codes.with.more.than.one.animal.ids.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(specimen.codes.with.more.than.one.animal.ids.per.country.df)=NULL

 # subset to specific country
specimen.codes.with.more.than.one.animal.ids.per.country.df=
  specimen.codes.with.more.than.one.animal.ids.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(specimen.codes.with.more.than.one.animal.ids.per.country.df)>0){

    
  message("No, not all animal IDs are under a single specimen code. These are the specimen codes with more than one animal ID per country.")

    
    kableExtra::kbl(specimen.codes.with.more.than.one.animal.ids.per.country.df, 
                    caption = "Specimen codes with more than one Animal ID per country") %>%
      kableExtra::kable_paper(full_width = F) %>%
      kableExtra::column_spec(1, bold = T, border_right = T) %>%
      kableExtra::column_spec(2, width = "50em")
  }}

if(!exists("specimen.codes.with.more.than.one.animal.ids.per.country.df") |
    exists("specimen.codes.with.more.than.one.animal.ids.per.country.df") && 
   nrow(specimen.codes.with.more.than.one.animal.ids.per.country.df)==0){  

    
    specimen.codes.with.more.than.one.animal.ids.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(specimen.codes.with.more.than.one.animal.ids.per.country[[1]])<-NULL
       
    message("Yes, all specimen codes have a single animal ID")}

```
#
##### Are Animal Ids under a unique Specimen Code?
#
#
```{r checking animal ids 4, echo=FALSE, warning=FALSE, cache=FALSE, eval=T}

# each animal id is used for a single specimen code?

animal.ids.with.more.than.one.specimen.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
  filter(!is.na(Animal_ID))%>%
  distinct(Specimen_code, Animal_ID, Country)%>%
  dplyr::count(Animal_ID)%>%
  filter(n>1)%>%
  dplyr::select(Animal_ID))

temp=
mapply(function(x, y) x[x$Animal_ID%in%y$Animal_ID,]%>%
      distinct(Specimen_code, Animal_ID, Country)%>%
      dplyr::select(Country, Animal_ID, Specimen_code),
       data.per.country.spec,
       animal.ids.with.more.than.one.specimen.per.country, SIMPLIFY = F)

animal.ids.with.more.than.one.specimen.per.country=temp


if(nrow(do.call(rbind, animal.ids.with.more.than.one.specimen.per.country))>0){  

  
  animal.ids.with.more.than.one.specimen.per.country=
  do.call(
  rbind, animal.ids.with.more.than.one.specimen.per.country)%>%
  dplyr::select(Country, Animal_ID, Specimen_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
animal.ids.with.more.than.one.specimen.per.country=
lapply(sort(unique(animal.ids.with.more.than.one.specimen.per.country$Country)), function(x) 
  animal.ids.with.more.than.one.specimen.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Animal_ID, Specimen_code))

animal.ids.with.more.than.one.specimen.per.country=
lapply(animal.ids.with.more.than.one.specimen.per.country, function(x)
  x%>%group_by(Country, Animal_ID)%>%
  mutate(Specimen_code=paste(Specimen_code, collapse = " "))%>%
  distinct(Country, Animal_ID, Specimen_code))

# name the list
names(animal.ids.with.more.than.one.specimen.per.country)=sapply(
  animal.ids.with.more.than.one.specimen.per.country, function(x) unique(x$Country))


  animal.ids.with.more.than.one.specimen.per.country.df=
    do.call(rbind, animal.ids.with.more.than.one.specimen.per.country)

   #delete rownames
  rownames(animal.ids.with.more.than.one.specimen.per.country.df)=NULL

    animal.ids.with.more.than.one.specimen.per.country.df=
    animal.ids.with.more.than.one.specimen.per.country.df[order(
      animal.ids.with.more.than.one.specimen.per.country.df$Animal_ID),]

 # subset to specific country
animal.ids.with.more.than.one.specimen.per.country.df=
  animal.ids.with.more.than.one.specimen.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(animal.ids.with.more.than.one.specimen.per.country.df)>0){

             
     message("No, not all animal IDs are under a single specimen code. There are animal IDs under more than one specimen
code per country")   
      
    kableExtra::kbl(animal.ids.with.more.than.one.specimen.per.country.df, 
                    caption = "Animal IDs in more than one specimen code per country") %>%
      kableExtra::kable_paper(full_width = F) %>%
      kableExtra::column_spec(1, bold = T, border_right = T) %>%
      kableExtra::column_spec(2, width = "8em")%>%
      kableExtra::column_spec(3, width = "30em")%>%

      kableExtra::collapse_rows(1)}}


if(!exists("animal.ids.with.more.than.one.specimen.per.country.df") |
    exists("animal.ids.with.more.than.one.specimen.per.country.df") && 
   nrow(animal.ids.with.more.than.one.specimen.per.country.df)==0){  
  
      animal.ids.with.more.than.one.specimen.per.country.df=
        list(data.frame(Country="", Animal_ID="", Specimen_code=""))
   
  rownames(animal.ids.with.more.than.one.specimen.per.country[[1]])<-NULL
  
  message("Yes, all animal IDs are under a single specimen code")

}
```
### DATE FOUND
#
##### Are all the dates when specimens were found provided?
#
#
```{r checking date found, echo=FALSE, warning=FALSE, eval=T, cache=F}

specimen.codes.with.date.found.as.na.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(is.na(Date_Found))%>%
    dplyr::select(Country, Specimen_code)%>%
    distinct(Country, Specimen_code))



if(nrow(do.call(rbind, specimen.codes.with.date.found.as.na.per.country))>0){  

  specimen.codes.with.date.found.as.na.per.country=
  do.call(
  rbind, specimen.codes.with.date.found.as.na.per.country)%>%
  dplyr::select(Country, Specimen_code)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
specimen.codes.with.date.found.as.na.per.country=
lapply(sort(unique(specimen.codes.with.date.found.as.na.per.country$Country)), function(x) 
  specimen.codes.with.date.found.as.na.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(specimen.codes.with.date.found.as.na.per.country)=sapply(
  specimen.codes.with.date.found.as.na.per.country, function(x) unique(x$Country))
    
# order by specimen code
specimen.codes.with.date.found.as.na.per.country=
  lapply(specimen.codes.with.date.found.as.na.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
specimen.codes.with.date.found.as.na.per.country.df=
  lapply(specimen.codes.with.date.found.as.na.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  specimen.codes.with.date.found.as.na.per.country.df=data.frame(
    Country=names(specimen.codes.with.date.found.as.na.per.country.df), 
    Specimen_code=unlist(specimen.codes.with.date.found.as.na.per.country.df, use.names = F))

   specimen.codes.with.date.found.as.na.per.country.df=
     specimen.codes.with.date.found.as.na.per.country.df[
       specimen.codes.with.date.found.as.na.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(specimen.codes.with.date.found.as.na.per.country.df)=NULL 

 # subset to specific country
specimen.codes.with.date.found.as.na.per.country.df=
  specimen.codes.with.date.found.as.na.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(specimen.codes.with.date.found.as.na.per.country.df)>0){
  
  message("No. Not all the dates when specimens were found are provided. These are the specimens with date found as NA
per country")
  
  kableExtra::kbl(specimen.codes.with.date.found.as.na.per.country.df, 
                      caption = "Specimens with no Date Found per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, width = "30em")
  # print(specimen.codes.with.animal.ids.as.na.per.country)
}}

if(!exists("specimen.codes.with.date.found.as.na.per.country.df") |
    exists("specimen.codes.with.date.found.as.na.per.country.df") && 
   nrow(specimen.codes.with.date.found.as.na.per.country.df)==0){  
    
    specimen.codes.with.date.found.as.na.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(specimen.codes.with.date.found.as.na.per.country[[1]])<-NULL
    
    message("Yes, all the dates when specimens were found are provided")}


```
#
### HOW FOUND
#
##### Is "how found" reported in WHIP?
#
This is an important field because it allows to identify how is contirbuting more to the surveillance
```{r specimen how found, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

spec.how.found.not.reported.per.country=

lapply(data.per.country.spec, function(x)
  x%>%filter(is.na(How_found))%>%dplyr::select(Country, Event_Code, Specimen_code, How_found)%>%distinct())

# if there are rows with wrong latitude

if(nrow(do.call(rbind,spec.how.found.not.reported.per.country))>0){  

spec.how.found.not.reported.per.country=do.call(
  rbind, spec.how.found.not.reported.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.how.found.not.reported.per.country=
lapply(sort(unique(spec.how.found.not.reported.per.country$Country)), function(x) 
  spec.how.found.not.reported.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.how.found.not.reported.per.country)=sapply(
  spec.how.found.not.reported.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.how.found.not.reported.per.country=
  lapply(spec.how.found.not.reported.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.how.found.not.reported.per.country.df=
  lapply(spec.how.found.not.reported.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.how.found.not.reported.per.country.df=data.frame(
    Country=names(spec.how.found.not.reported.per.country.df), 
    Specimen_code=unlist(spec.how.found.not.reported.per.country.df, use.names = F))

   spec.how.found.not.reported.per.country.df=
     spec.how.found.not.reported.per.country.df[
       spec.how.found.not.reported.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.how.found.not.reported.per.country.df)=NULL 

 # subset to specific country
spec.how.found.not.reported.per.country.df=
  spec.how.found.not.reported.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.how.found.not.reported.per.country.df)>0){  
  
  message("No, the data show that some specimens do not have how these were found repoerted. These are the Specimen codes that do not have the 'how found' field reported")
  
  kableExtra::kbl(spec.how.found.not.reported.per.country.df, 
                  caption = "Specimens that is unknown how they were found")%>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(spec.how.found.not.reported.per.country.df), width = "30em", border_right = T)
}}

if(!exists("spec.how.found.not.reported.per.country.df") |
    exists("spec.how.found.not.reported.per.country.df") && 
   nrow(spec.how.found.not.reported.per.country.df)==0){  
  
  spec.how.found.not.reported.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.how.found.not.reported.per.country[[1]])<-NULL

  
  message("Yes, all specimens have the how found item reported")}
  

```
#
### CAPTIVITY CATEGORY
#
##### Is "Captivity Category" reported in WHIP?
#
This is an important field because it allows to identify how is contributing more to the surveillance
```{r specimen captivit category, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

spec.captive.category.not.reported.per.country=

lapply(data.per.country.spec, function(x)
  x%>%filter(is.na(Captivity_Category))%>%dplyr::select(Country, Event_Code, Specimen_code, Captivity_Category)%>%distinct())

# if there are rows with wrong latitude

if(nrow(do.call(rbind,spec.captive.category.not.reported.per.country))>0){  

spec.captive.category.not.reported.per.country=do.call(
  rbind, spec.captive.category.not.reported.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.captive.category.not.reported.per.country=
lapply(sort(unique(spec.captive.category.not.reported.per.country$Country)), function(x) 
  spec.captive.category.not.reported.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.captive.category.not.reported.per.country)=sapply(
  spec.captive.category.not.reported.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.captive.category.not.reported.per.country=
  lapply(spec.captive.category.not.reported.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.captive.category.not.reported.per.country.df=
  lapply(spec.captive.category.not.reported.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.captive.category.not.reported.per.country.df=data.frame(
    Country=names(spec.captive.category.not.reported.per.country.df), 
    Specimen_code=unlist(spec.captive.category.not.reported.per.country.df, use.names = F))

   spec.captive.category.not.reported.per.country.df=
     spec.captive.category.not.reported.per.country.df[
       spec.captive.category.not.reported.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.captive.category.not.reported.per.country.df)=NULL 

 # subset to specific country
spec.captive.category.not.reported.per.country.df=
  spec.captive.category.not.reported.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.captive.category.not.reported.per.country.df)>0){  
  
  
  message("No, the data show that some specimens do not have the captive category. These are the Specimen codes that do
not have the 'Captive category' found' field reported")
  
  kableExtra::kbl(spec.captive.category.not.reported.per.country.df, 
                  caption = "Specimens that is unknown what was their captive category when they were found")%>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(spec.how.found.not.reported.per.country.df), width = "30em", border_right = T)
}}

if(!exists("spec.captive.category.not.reported.per.country.df") |
    exists("spec.captive.category.not.reported.per.country.df") && 
   nrow(spec.captive.category.not.reported.per.country.df)==0){  

  
  spec.captive.category.not.reported.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.captive.category.not.reported.per.country[[1]])<-NULL

  
  message("Yes, all specimens have the captivity category item reported")}
  

```
#
### NECROPSY LEVEL
#
##### Is the "necropsy level" reported in WHIP? 
#
If no necropsy was conducted with the specimen, then we need the "no necropsy" level provided in the field 'Necropsy level".
```{r specimen necropsy level, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}

spec.necropsy.level.not.reported.per.country=

lapply(data.per.country.spec, function(x)
  x%>%filter(is.na(How_found))%>%dplyr::select(Country, Event_Code, Specimen_code, Necropsy_level)%>%distinct())

# if there are rows with wrong latitude

if(nrow(do.call(rbind,spec.necropsy.level.not.reported.per.country))>0){  

spec.necropsy.level.not.reported.per.country=do.call(
  rbind, spec.necropsy.level.not.reported.per.country)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
spec.necropsy.level.not.reported.per.country=
lapply(sort(unique(spec.necropsy.level.not.reported.per.country$Country)), function(x) 
  spec.necropsy.level.not.reported.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(spec.necropsy.level.not.reported.per.country)=sapply(
  spec.necropsy.level.not.reported.per.country, function(x) unique(x$Country))
    
# order by specimen code
spec.necropsy.level.not.reported.per.country=
  lapply(spec.necropsy.level.not.reported.per.country, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
spec.necropsy.level.not.reported.per.country.df=
  lapply(spec.necropsy.level.not.reported.per.country, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  spec.necropsy.level.not.reported.per.country.df=data.frame(
    Country=names(spec.necropsy.level.not.reported.per.country.df), 
    Specimen_code=unlist(spec.necropsy.level.not.reported.per.country.df, use.names = F))

   spec.necropsy.level.not.reported.per.country.df=
     spec.necropsy.level.not.reported.per.country.df[
       spec.necropsy.level.not.reported.per.country.df$Specimen_code!="",]

   #delete rownames
  rownames(spec.necropsy.level.not.reported.per.country.df)=NULL 

 # subset to specific country
spec.necropsy.level.not.reported.per.country.df=
  spec.necropsy.level.not.reported.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(spec.necropsy.level.not.reported.per.country.df)>0){  
  
  
  message("No, the data show that some specimens do not have the level of necropsy. These are the Specimen codes that do
not have the 'level of necropsy' field completed")
  
  kableExtra::kbl(spec.necropsy.level.not.reported.per.country.df, 
                  caption = "Specimens whose necropsy level is unknown")%>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(spec.necropsy.level.not.reported.per.country.df), width = "30em", border_right = T)
}}

if(!exists("spec.necropsy.level.not.reported.per.country.df") |
    exists("spec.necropsy.level.not.reported.per.country.df") && 
   nrow(spec.necropsy.level.not.reported.per.country.df)==0){  

  
  spec.necropsy.level.not.reported.per.country=list(data.frame(Country="", Specimen_code=""))
   
  rownames(spec.necropsy.level.not.reported.per.country[[1]])<-NULL

  
  message("Yes, all specimens have the necropsy level reported")}
  

```
#
### NO NECROPSY LEVEL, NO NECROPSY REPORTED, AND NO SAMPLE INVENTORY
#
##### Are there specimens without a necropsy report, no "necropsy level" reported, and no sample inventory in WHIP? 
#
The specimens that match these three conditions can be confused with observations because there are actually no specimens. Some of these specimens will be repeated above. If you are expecting to conduct a necropsy, please add "Pending Necropsy" in the "Necropsy level" field, or add "No Necropsy". Complete the sample inventory. Record those specimens that are actually observations.

```{r specimen no necropsy report, no necropsy level or no necropsy reported and no sample inventory, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}


# specimens wo smaples and necropsy


list.of.potential.observations=
lapply(data.per.country.spec, function(x)
x%>%dplyr::select(Country, Specimen_code, Sample_type, Date_Sampled, meta_has_sample_inventory, Necropsy, Necropsy_level)%>% # date sampled is mandatory
  distinct()%>%
  arrange(Country, Specimen_code)%>%
  filter(meta_has_sample_inventory=="No" &
          Necropsy_level== "No Necropsy" | is.na(Necropsy_level)))


# if there are rows with wrong latitude

if(nrow(do.call(rbind,list.of.potential.observations))>0){  

list.of.potential.observations=do.call(
  rbind, list.of.potential.observations)%>%
  dplyr::select(Country, Specimen_code)


# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
list.of.potential.observations=
lapply(sort(unique(list.of.potential.observations$Country)), function(x) 
  list.of.potential.observations%>%filter(Country==x)%>%
  dplyr::select(Country, Specimen_code)%>%
  distinct(Country, Specimen_code))

# name the list
names(list.of.potential.observations)=sapply(
  list.of.potential.observations, function(x) unique(x$Country))
    
# order by specimen code
list.of.potential.observations=
  lapply(list.of.potential.observations, function(x)
  x[order(x[,"Specimen_code"]), ])

# move to da dataset with the event codes in a single row
list.of.potential.observations.df=
  lapply(list.of.potential.observations, function(x)
  data.frame(Specimen_code=paste(unique(x$Specimen_code), collapse = " ")))


  list.of.potential.observations.df=data.frame(
    Country=names(list.of.potential.observations.df), 
    Specimen_code=unlist(list.of.potential.observations.df, use.names = F))

   list.of.potential.observations.df=
     list.of.potential.observations.df[
       list.of.potential.observations.df$Specimen_code!="",]

   #delete rownames
  rownames(list.of.potential.observations.df)=NULL 

 # subset to specific country
list.of.potential.observations.df=
  list.of.potential.observations.df%>%filter(Country==params$country.of.interest)

if(nrow(list.of.potential.observations.df)>0){  
  
  
  message("Yes, the data show that some specimens could be observations. These are the Specimen codes that do 
not have anything associated with necropsy or samples")
  
  kableExtra::kbl(list.of.potential.observations.df, 
                  caption = "Specimens that may be observations")%>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(spec.necropsy.level.not.reported.per.country.df), width = "30em", border_right = T)
}}


if(!exists("list.of.potential.observations.df") |
    exists("list.of.potential.observations.df") && 
   nrow(list.of.potential.observations.df)==0){  

  
  list.of.potential.observations=list(data.frame(Country="", Specimen_code=""))
   
  rownames(list.of.potential.observations[[1]])<-NULL

  
  message("No, all specimens have a necropsy (carcass) or samples associated")}

```



#
#
### SUMMARY ISSUES AT THE OBSERVATION LEVEL
#
"Yes" cells indicate problems for the item specified in the corresponding column name. Absence of a table below means that there are not issues at the observation level.
```{r observation table, echo=FALSE, warning=FALSE, eval=T, cache=F}


# observation.codes.with.invalid.proj.tag.per.country.df=
# 
#   do.call(rbind, observation.codes.with.invalid.proj.tag.per.country)
# 
# observation.codes.with.invalid.proj.tag.per.country.df$Invalid_project_tag="Yes"




# obs.provided.and.correct.countries.inconsistent.project.tag.df=
# 
#     do.call(rbind, observation.codes.with.invalid.proj.tag.per.country)
# 
# obs.provided.and.correct.countries.inconsistent.project.tag.df$Inconsistent_country_project_tag="Yes"



# obs.more.than.one.project.tag.per.country.df=
#   
#       do.call(rbind, obs.more.than.one.project.tag.per.country)
# 
# obs.more.than.one.project.tag.per.country.df$more_than_one_project_tag="Yes"




obs.codes.date.found.earlier.start.date.per.country.df=
  
  do.call(rbind, obs.codes.date.found.earlier.start.date.per.country)

obs.codes.date.found.earlier.start.date.per.country.df$Inconsistent_observed_start_date="Yes"




obs.codes.date.found.earlier.end.date.per.country.df=

  do.call(rbind, obs.codes.date.found.earlier.start.date.per.country)

obs.codes.date.found.earlier.end.date.per.country.df$Inconsistent_observed_end_date="Yes"




# data showing the issues per Specimen code per country
# observation.codes.with.issues=full_join(observation.codes.with.invalid.proj.tag.per.country.df,
#                                         obs.provided.and.correct.countries.inconsistent.project.tag.df,
#                                         by=c("Country", "Observation_code"))


# observation.codes.with.issues=full_join(observation.codes.with.issues, 
#                                         obs.more.than.one.project.tag.per.country.df,
#                                         by=c("Country", "Observation_code"))


# observation.codes.with.issues=full_join(observation.codes.with.issues, 
#                                         obs.codes.date.found.earlier.start.date.per.country.df, 
#                                         by=c("Country", "Observation_code"))

observation.codes.with.issues=full_join(obs.codes.date.found.earlier.start.date.per.country.df, #observation.codes.with.issues, 
                                        obs.codes.date.found.earlier.end.date.per.country.df,
                                        by=c("Country", "Observation_code"))


observation.codes.with.issues=observation.codes.with.issues%>%filter(Observation_code!="")

#final df sorted by country
observation.codes.with.issues=observation.codes.with.issues[order(
  observation.codes.with.issues$Country,
  observation.codes.with.issues$Observation_code),]

# observation.codes.with.issues=
# observation.codes.with.issues%>%mutate(Event_Code=
#                                          sapply(Observation_code, function(x)
#                                          obs[obs$Observation_code%in%x, ]$Event_Code))%>%
#   dplyr::select(Country,Event_Code, Observation_code, 
#          Invalid_project_tag, 
#          Inconsistent_country_project_tag, 
#          more_than_one_project_tag,
#          Inconsistent_observed_start_date,
#          Inconsistent_observed_end_date)

rownames(observation.codes.with.issues)=NULL

# subset to specific country
observation.codes.with.issues=
  observation.codes.with.issues%>%filter(Country==params$country.of.interest)


if(nrow(observation.codes.with.issues)>0){
  
    # removing columns were everything is NA
observation.codes.with.issues=
observation.codes.with.issues%>%dplyr::select_if(~ !all(is.na(.)))
  
  
  if(any(is.na(observation.codes.with.issues))){
  observation.codes.with.issues[is.na(observation.codes.with.issues)]="No"}
 
message("Please scroll down the table below to see the complete dataset")  
  
 kableExtra::kbl(observation.codes.with.issues,
                  caption = "Observation codes with problems per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(observation.codes.with.issues), border_right = T, width = "8em")%>%

    scroll_box(width = "100%", height = "600px")

}else{
  
  message("No observation codes with problems")  }
```
#
#
### SUMMARY ISSUES AT THE SPECIMEN LEVEL
#
"Yes" cells indicate problems for the item specified in the corresponding column name. Absence of a table below means that there are not issues at the specimen level.

```{r table specimens, echo=FALSE, warning=FALSE, eval=T, cache=F}


#   specimen.codes.with.invalid.proj.tag.per.country.df=
# 
#   do.call(rbind, specimen.codes.with.invalid.proj.tag.per.country)
# 
# specimen.codes.with.invalid.proj.tag.per.country.df$Invalid_project_tag="Yes"
 


#   spec.provided.and.correct.countries.inconsistent.project.tag.df=
# 
#   do.call(rbind, spec.provided.and.correct.countries.inconsistent.project.tag)
# 
# spec.provided.and.correct.countries.inconsistent.project.tag.df$Inconsistent_project_tag="Yes"



# spec.more.than.one.project.tag.per.country.df=
#   
#     do.call(rbind, spec.more.than.one.project.tag.per.country)
# 
# spec.more.than.one.project.tag.per.country.df$more_than_one_project_tag="Yes"




spec.codes.date.found.earlier.start.date.per.country.df=

  do.call(rbind, spec.codes.date.found.earlier.start.date.per.country)

spec.codes.date.found.earlier.start.date.per.country.df$Inconsistent_found_start_date="Yes"



spec.codes.date.found.earlier.end.date.per.country.df=

  do.call(rbind, spec.codes.date.found.earlier.end.date.per.country)

spec.codes.date.found.earlier.end.date.per.country.df$Inconsistent_found_end_date="Yes"



spec.received.before.event.started.per.country.df =
  
  do.call(rbind, spec.received.before.event.started.per.country)

spec.received.before.event.started.per.country.df$Inconsistent_received_start_date="Yes"



spec.received.earlier.than.found.date.per.country.df =
  
  do.call(rbind, spec.codes.date.found.earlier.end.date.per.country)

spec.received.earlier.than.found.date.per.country.df$Inconsistent_received_found_date="Yes"



spec.date.necropsy.earlier.than.start.date.per.country.df =
  
  do.call(rbind, spec.date.necropsy.earlier.than.start.date.per.country)

spec.date.necropsy.earlier.than.start.date.per.country.df$Necropsy_before_start_date="Yes"



spec.date.necropsy.earlier.than.date.found.per.country.df=

  do.call(rbind, spec.date.necropsy.earlier.than.date.found.per.country)

spec.date.necropsy.earlier.than.date.found.per.country.df$Necropsy_before_date_found="Yes"



spec.date.necropsy.earlier.than.date.received.per.country.df=
  
    do.call(rbind, spec.date.necropsy.earlier.than.date.received.per.country)

spec.date.necropsy.earlier.than.date.received.per.country.df$Necropsy_before_date_received="Yes"



specimen.codes.with.animal.ids.as.na.per.country.df=
  
  do.call(rbind, specimen.codes.with.animal.ids.as.na.per.country)

specimen.codes.with.animal.ids.as.na.per.country.df$Animal_ids_as_na.="Yes"



# specimen.codes.with.wrong.animal.ids.per.country.df=
#   
#    do.call(rbind, specimen.codes.with.wrong.animal.ids.per.country)
# 
# specimen.codes.with.wrong.animal.ids.per.country.df$Wrong_animal_id="Yes"
 


specimen.codes.with.more.than.one.animal.ids.per.country.df=
  
  do.call(rbind, specimen.codes.with.more.than.one.animal.ids.per.country)

specimen.codes.with.more.than.one.animal.ids.per.country.df$Many_animal_ids="Yes"


     
animal.ids.with.more.than.one.specimen.per.country.df=
    
    do.call(rbind, animal.ids.with.more.than.one.specimen.per.country)
  
animal.ids.with.more.than.one.specimen.per.country.df$Repeated_animal_ids="Yes"



specimen.codes.with.date.found.as.na.per.country.df=
  
  do.call(rbind, specimen.codes.with.date.found.as.na.per.country)

specimen.codes.with.date.found.as.na.per.country.df$No_date_found="Yes"



spec.how.found.not.reported.per.country.df=
  
  do.call(rbind, spec.how.found.not.reported.per.country)

spec.how.found.not.reported.per.country.df$No_how_found="Yes"




spec.captive.category.not.reported.per.country.df=
  
  do.call(rbind, spec.captive.category.not.reported.per.country)

spec.captive.category.not.reported.per.country.df$No_captive_category="Yes"



spec.necropsy.level.not.reported.per.country.df=
  
    do.call(rbind, spec.necropsy.level.not.reported.per.country)

spec.necropsy.level.not.reported.per.country.df$No_necropsy_level="Yes"


list.of.potential.observations.df=
  
    do.call(rbind, list.of.potential.observations)

list.of.potential.observations.df$No_specimens_associated="Yes"


# data showing the issues per Specimen code per country
# specimen.codes.with.issues=full_join(specimen.codes.with.invalid.proj.tag.per.country.df,
#                                      spec.provided.and.correct.countries.inconsistent.project.tag.df,
#                                      by=c("Country", "Specimen_code"))
# 
# 
# specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
#                                      spec.more.than.one.project.tag.per.country.df,
#                                      by=c("Country", "Specimen_code"))


# specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
#                                      spec.codes.date.found.earlier.start.date.per.country.df, 
#                                      by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(#specimen.codes.with.issues,
                                     spec.codes.date.found.earlier.start.date.per.country.df,
                                     spec.codes.date.found.earlier.end.date.per.country.df,
                                     by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     spec.received.before.event.started.per.country.df,
                                     by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     spec.received.earlier.than.found.date.per.country.df,
                                     by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues,
                                     spec.date.necropsy.earlier.than.start.date.per.country.df,
                                     by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues,
                                     spec.date.necropsy.earlier.than.date.found.per.country.df, 
                                     by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                   spec.date.necropsy.earlier.than.date.received.per.country.df, 
                                     by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     specimen.codes.with.animal.ids.as.na.per.country.df, 
                                     by=c("Country", "Specimen_code"))

# specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
#                                      specimen.codes.with.wrong.animal.ids.per.country.df, 
#                                      by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     specimen.codes.with.more.than.one.animal.ids.per.country.df,
                                     by=c("Country", "Specimen_code"))


specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     animal.ids.with.more.than.one.specimen.per.country.df,
                                     by=c("Country", "Specimen_code"))


specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     specimen.codes.with.date.found.as.na.per.country.df,
                                     by=c("Country", "Specimen_code"))


specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     spec.how.found.not.reported.per.country.df,
                                     by=c("Country", "Specimen_code"))


specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     spec.captive.category.not.reported.per.country.df,
                                     by=c("Country", "Specimen_code"))


specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     spec.necropsy.level.not.reported.per.country.df,
                                     by=c("Country", "Specimen_code"))

specimen.codes.with.issues=full_join(specimen.codes.with.issues, 
                                     list.of.potential.observations.df,
                                     by=c("Country", "Specimen_code"))

# the rows wo specimen code come from tables wo data so filter them

specimen.codes.with.issues=specimen.codes.with.issues%>%filter(Specimen_code!="")



#final df sorted by country and specimen code
specimen.codes.with.issues=specimen.codes.with.issues[order(
  specimen.codes.with.issues$Country,
  specimen.codes.with.issues$Specimen_code),]


rownames(specimen.codes.with.issues)=NULL

# subset to specific country
specimen.codes.with.issues=
  specimen.codes.with.issues%>%filter(Country==params$country.of.interest)

# delete extra column
specimen.codes.with.issues=specimen.codes.with.issues%>%dplyr::select(-Animal_ID)


if(nrow(specimen.codes.with.issues)>0){
  
  
# removing columns were everything is No
specimen.codes.with.issues=
specimen.codes.with.issues%>%dplyr::select_if(~ !all(is.na(.)))
  
# changing NAs for No
   if(any(is.na(specimen.codes.with.issues))){
  specimen.codes.with.issues[is.na(specimen.codes.with.issues)]="No"}

  
  
message("Please scroll the table below down and left-right to see the complete dataset")  
  
 kableExtra::kbl(specimen.codes.with.issues,
                  caption = "Specimen codes with problems per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(specimen.codes.with.issues), border_right = T, width = "8em")%>%
   

   #kableExtra::kable_styling(fixed_thead = T)
    scroll_box(width = "100%", height = "600px")

}else{
  message("No specimen codes with problems")}  

  
```

## SAMPLES

#### SAMPLE IDS

##### Are all Sample IDs provided?

```{r sample ids, echo=FALSE, warning=FALSE, eval=T, cache=FALSE}


  # concatenate the specimen code, sample type and medium type to id the sample
  
specimen.codes.with.sample.ids.as.na.per.country=
  lapply(data.per.country.spec, function(x)
    x%>%
      filter(is.na(Sample_ID) & Has_sample_inventory=="Yes" & !is.na(Sample_type)))


if(nrow(do.call(rbind, specimen.codes.with.sample.ids.as.na.per.country))>0){

  
  specimen.codes.with.sample.ids.as.na.per.country=
  do.call(
  rbind, specimen.codes.with.sample.ids.as.na.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code,  Sample_ID, Sample_type, Medium_Type, Date_Sampled)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
specimen.codes.with.sample.ids.as.na.per.country=
lapply(sort(unique(specimen.codes.with.sample.ids.as.na.per.country$Country)), function(x) 
  specimen.codes.with.sample.ids.as.na.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)%>%
  distinct(Country, Event_Code, Specimen_code,  Sample_ID, Sample_type, Medium_Type, Date_Sampled))

# name the list
names(specimen.codes.with.sample.ids.as.na.per.country)=sapply(
  specimen.codes.with.sample.ids.as.na.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
specimen.codes.with.sample.ids.as.na.per.country.df=
do.call(rbind, specimen.codes.with.sample.ids.as.na.per.country)

#order by country and specimen code
specimen.codes.with.sample.ids.as.na.per.country.df=
  specimen.codes.with.sample.ids.as.na.per.country.df[order(
    specimen.codes.with.sample.ids.as.na.per.country.df$Country, 
    specimen.codes.with.sample.ids.as.na.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(specimen.codes.with.sample.ids.as.na.per.country.df)=NULL 

   # subset to specific country
specimen.codes.with.sample.ids.as.na.per.country.df=
specimen.codes.with.sample.ids.as.na.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(specimen.codes.with.sample.ids.as.na.per.country.df)>0){  


  message("No. Not all the sample IDs are provided. These are the samples whose sample ID is NA per country.
Please scroll the table below down and left-right to see the complete dataset")
  
  kableExtra::kbl(specimen.codes.with.sample.ids.as.na.per.country.df, 
                      caption = "Samples without Sample ID per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:7, border_right = T, width = "15em")%>%
    # collapse_rows(columns = 2:3)%>%

    scroll_box(width = "100%", height = "600px")

  # print(specimen.codes.with.animal.ids.as.na.per.country)
}}

if(!exists("specimen.codes.with.sample.ids.as.na.per.country.df") |
    exists("specimen.codes.with.sample.ids.as.na.per.country.df") && 
   nrow(specimen.codes.with.sample.ids.as.na.per.country.df)==0){  

    
  specimen.codes.with.sample.ids.as.na.per.country=list(
    data.frame(Country="", 
               Event_Code="", 
               Specimen_code="", 
               Sample_ID="", 
               Sample_type="",
               Medium_Type="",
               Date_Sampled=""
               ))
   
  rownames(specimen.codes.with.sample.ids.as.na.per.country[[1]])<-NULL
    
    message("Yes, all samples IDs are provided")}


```
<!-- # -->
<!-- # -->
<!-- ##### Do the sample IDs follow the standardized labeling structure? -->
<!-- # -->
```{r sample ids 2, echo=FALSE, warning=FALSE, eval=F, cache=FALSE}

country.abbreviations=c("KH", "LA", "VN")

project.abbreviations=c("W")

taxa=list(A="Amphibian", B="Bat", C="Carnivore",
          E="Elephant", F="Fish", G="Pangolin",
          L="Reptile", M="Marine mammal", P="Primate",
          R="Rodent", S="Swine", U="Ungulate",
          W="Wild bird", X="Environmental")

project.country.abbreviations=paste0(rep(project.abbreviations,
                                         each = length(country.abbreviations))
                                     , country.abbreviations, "-")


sample.type=c("OS", "RS", "NS", "US", "FF", "DF", "UR", "CC", "GC", "VM",
              "FL", "JF", "CF", "ML", "BW","BP", "BS", "BC", "AG", "BM", 
              "BN", "BR", "ES", "EY", "GB", "FR", "FS", "HT", "HR", "IL",
              "IS", "KD", "LN", "LU", "LV", "MG", "MT", "MU", "NV", "OV", "PN",
              "SC", "SK", "SP", "ST", "TG", "TO", "TN", "TR", "TS", "UB", "UM",
              "UT", "DM", "SM", "FM", "PL", "PM", "PT", "PF", "PR", "PP", "PZ",
              "FP", "PO", "SD", "SL", "WA")

medium = c("A", "B", "F", "P", "R", "T", "U", "V")

# where sample ID are provided
spec.sample.id.provided=spec[!is.na(spec$Sample_ID),]

# first part of sample ids when they are not NA
first.part.sample.ids.project.country.hyphen= # one letter for project, 2 letters for country, and hyphen
  substr(spec.sample.id.provided$Sample_ID, 1,5) 

#in the second part of the label
second.part.sample.ids.taxa.numeric=  # one letter for taxa, 3 numbers
  sapply(strsplit(spec.sample.id.provided$Sample_ID, "-"), function(x) x[2])


#in the third part of the label

third.part.sample.ids.taxa.numeric=  # two letter for sample type, 
  sapply(strsplit(spec.sample.id.provided$Sample_ID, "-"), function(x) x[3])

# in the fourth part of the label

fourth.part.sample.ids.taxa.numeric=  # one letter for taxa, 3 numbers
  sapply(strsplit(spec.sample.id.provided$Sample_ID, "-"), function(x) x[4])




  wrong.sample.id.first.part=
    
    spec.sample.id.provided$Sample_ID[
      
      !(substring(first.part.sample.ids.project.country.hyphen, 1,1)%in%project.abbreviations) | # first piece does have a valid project letter?
        
        !(substring(first.part.sample.ids.project.country.hyphen, 2,3)%in%country.abbreviations) | # second piece has valid country abbreviations?
        
        substring(first.part.sample.ids.project.country.hyphen, 4,4)!="-"]
  
  
  
  
  wrong.sample.id.second.part=
    
    spec.sample.id.provided$Sample_ID[
      
      !(substring(second.part.sample.ids.taxa.numeric, 1,1)%in%names(taxa)) | # second piece does have a valid taxa letter?
        
        is.na(as.numeric(substring(second.part.sample.ids.taxa.numeric, 2,4)))]
  
  
  
  
  wrong.sample.id.third.part=
    
    spec.sample.id.provided$Sample_ID[ #third piece does ahave a valid sample type abb
    
    !(substring(third.part.sample.ids.taxa.numeric, 1,2)%in%sample.type) & 
    
    nchar(third.part.sample.ids.taxa.numeric)!=2] # then there is nothing afterwards
    
  
    
  
  wrong.sample.id.fourth.part=spec.sample.id.provided$Sample_ID[ #fourth piece does a have a valid medium type
    
    !(substring(fourth.part.sample.ids.taxa.numeric, 1)%in%medium)]
    
  
  # wrong sample ids
  wrong.sample.id=sort(unique(c(wrong.sample.id.first.part, 
                                wrong.sample.id.second.part, 
                                wrong.sample.id.third.part, 
                                wrong.sample.id.fourth.part)))
  
  
  
  specimen.codes.with.wrong.sample.ids.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
  filter(!is.na(Sample_ID) & Sample_ID%in%wrong.sample.id))

  
  if(nrow(do.call(rbind, specimen.codes.with.wrong.sample.ids.per.country))>0){

  specimen.codes.with.wrong.sample.ids.per.country=
  do.call(
  rbind, specimen.codes.with.wrong.sample.ids.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code,  Sample_ID, Sample_type, Medium_Type, Date_Sampled)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
specimen.codes.with.wrong.sample.ids.per.country=
lapply(sort(unique(specimen.codes.with.wrong.sample.ids.per.country$Country)), function(x) 
  specimen.codes.with.wrong.sample.ids.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)%>%
  distinct(Country, Event_Code, Specimen_code,  Sample_ID, Sample_type, Medium_Type, Date_Sampled))

# name the list
names(specimen.codes.with.wrong.sample.ids.per.country)=sapply(
  specimen.codes.with.wrong.sample.ids.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
specimen.codes.with.wrong.sample.ids.per.country.df=
do.call(rbind, specimen.codes.with.wrong.sample.ids.per.country)

#order by country and specimen code
specimen.codes.with.wrong.sample.ids.per.country.df=
  specimen.codes.with.wrong.sample.ids.per.country.df[order(
    specimen.codes.with.wrong.sample.ids.per.country.df$Country, 
    specimen.codes.with.wrong.sample.ids.per.country.df$Specimen_code),]

   #delete rownames
  rownames(specimen.codes.with.wrong.sample.ids.per.country.df)=NULL 

   # subset to specific country
specimen.codes.with.wrong.sample.ids.per.country.df=
specimen.codes.with.wrong.sample.ids.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(specimen.codes.with.wrong.sample.ids.per.country.df)>0){  
  
  
    message("No. Not all sample IDs provided follow the label format. These are the sample IDs with wrong format.
Please scroll the table below down and left-right to see the complete dataset if needed", appendLF = T)

    
  kableExtra::kbl(specimen.codes.with.wrong.sample.ids.per.country.df, 
                  caption = "Wrong sample IDs per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:6, border_right = T, width = "15em")%>%
    # collapse_rows(columns = 2:3)%>%
    scroll_box(width = "100%", height = "600px")
    
}}

  if(!exists("specimen.codes.with.wrong.sample.ids.per.country.df") |
    exists("specimen.codes.with.wrong.sample.ids.per.country.df") && 
   nrow(specimen.codes.with.wrong.sample.ids.per.country.df)==0){  

  specimen.codes.with.wrong.sample.ids.per.country=list(
    data.frame(Country="", 
               Event_Code="", 
               Specimen_code="", 
               Sample_ID="", 
               Sample_type="",
               Medium_Type="",
               Date_Sampled=""))
   
  rownames(specimen.codes.with.wrong.sample.ids.per.country[[1]])<-NULL
  
  message("Yes, all sample IDs provided have the correct format")}


```
#
#
##### Are sample IDs under a single event?
#
```{r sample ids 3, echo=FALSE, warning=FALSE, eval=T, cache=F}


data.temp=do.call(rbind, data.per.country.spec)

sample.ids.in.more.than.one.event.per.country=
  data.temp%>%
  filter(!is.na(Sample_ID))%>%
  distinct(Event_Code, Sample_ID, Country)%>%
  dplyr::count(Sample_ID)%>%
  filter(n>1)%>%
  dplyr::select(Sample_ID)

sample.ids.in.more.than.one.event.per.country=
lapply(data.per.country.spec, function(x)
      x[x$Sample_ID%in%sample.ids.in.more.than.one.event.per.country$Sample_ID,]%>%
      distinct(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)%>%
      dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled))


if(nrow(do.call(rbind, sample.ids.in.more.than.one.event.per.country))>0){  

  
  sample.ids.in.more.than.one.event.per.country=
  do.call(
  rbind, sample.ids.in.more.than.one.event.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
sample.ids.in.more.than.one.event.per.country=
lapply(sort(unique(sample.ids.in.more.than.one.event.per.country$Country)), function(x) 
  sample.ids.in.more.than.one.event.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled))

sample.ids.in.more.than.one.event.per.country=
lapply(sample.ids.in.more.than.one.event.per.country, function(x)
  x%>%#group_by(Country, Event_Code, Sample_ID)%>%
  # mutate(Specimen_code=paste(Specimen_code, collapse = " "))%>%
  distinct(Country, Event_Code, Sample_ID, Specimen_code,  Sample_type, Medium_Type, Date_Sampled))

# name the list
names(sample.ids.in.more.than.one.event.per.country)=sapply(
  sample.ids.in.more.than.one.event.per.country, function(x) unique(x$Country))


  sample.ids.in.more.than.one.event.per.country.df=
    do.call(rbind, sample.ids.in.more.than.one.event.per.country)

   #delete rownames
  rownames(sample.ids.in.more.than.one.event.per.country.df)=NULL

# sort 
  
  sample.ids.in.more.than.one.event.per.country.df=
    sample.ids.in.more.than.one.event.per.country.df[order(
      sample.ids.in.more.than.one.event.per.country.df$Sample_ID,
      sample.ids.in.more.than.one.event.per.country.df$Specimen_code),]

rownames(sample.ids.in.more.than.one.event.per.country.df)=NULL
  
   # subset to specific country
sample.ids.in.more.than.one.event.per.country.df=
sample.ids.in.more.than.one.event.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(sample.ids.in.more.than.one.event.per.country.df)>0){  
  


    message("No. Not all sample IDs are under a single event. These are the sample IDs repeated in more than one event
                Please scroll the table below down and left-right to see the complete dataset", appendLF = T)

    
  kableExtra::kbl(sample.ids.in.more.than.one.event.per.country.df, 
                  caption = "Sample ids in more than one event per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:7, border_right = T, width = "15em")%>%
    collapse_rows(columns = 4)
  
}}

if(!exists("sample.ids.in.more.than.one.event.per.country.df") |
    exists("sample.ids.in.more.than.one.event.per.country.df") && 
   nrow(sample.ids.in.more.than.one.event.per.country.df)==0){  

    
    sample.ids.in.more.than.one.event.per.country=list(
      data.frame(Country="",
               Event_Code="",   
               Specimen_code="", 
               Sample_ID="", 
               Sample_type="",
               Medium_Type="",
               Date_Sampled=""
               ))
    
    rownames(sample.ids.in.more.than.one.event.per.country[[1]])<-NULL

  
  message("Yes, all sample IDs are under a single event")}

```
#
#
##### Are sample IDs under a single specimen?
#
```{r sample ids 4, echo=FALSE, warning=FALSE, eval=T, cache=F}


sample.ids.in.more.than.one.specimen.per.country=
  data.temp%>%
  filter(!is.na(Sample_ID))%>%
  distinct(Specimen_code, Sample_ID)%>%
  dplyr::count(Sample_ID)%>%
  filter(n>1)%>%
  dplyr::select(Sample_ID)

sample.ids.in.more.than.one.specimen.per.country=
lapply(data.per.country.spec, function(x)
      x[x$Sample_ID%in%sample.ids.in.more.than.one.specimen.per.country$Sample_ID,]%>%
      distinct(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)%>%
      dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled))


  
if(nrow(do.call(rbind, sample.ids.in.more.than.one.specimen.per.country))>0){  

  
  sample.ids.in.more.than.one.specimen.per.country=
  do.call(
  rbind, sample.ids.in.more.than.one.specimen.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)

# sort by sample ID
  
  sample.ids.in.more.than.one.specimen.per.country=
    sample.ids.in.more.than.one.specimen.per.country[order(
      sample.ids.in.more.than.one.specimen.per.country$Sample_ID,
      sample.ids.in.more.than.one.specimen.per.country$Specimen_code),]


    
  
# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
sample.ids.in.more.than.one.specimen.per.country=
lapply(sort(unique(sample.ids.in.more.than.one.specimen.per.country$Country)), function(x) 
  sample.ids.in.more.than.one.specimen.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled))

sample.ids.in.more.than.one.specimen.per.country=
lapply(sample.ids.in.more.than.one.specimen.per.country, function(x)
  x%>%#group_by(Country, Event_Code, Sample_ID)%>%
  # mutate(Specimen_code=paste(Specimen_code, collapse = " "))%>%
  distinct(Country, Event_Code, Specimen_code, Sample_ID,  Sample_type, Medium_Type, Date_Sampled))

# name the list
names(sample.ids.in.more.than.one.specimen.per.country)=sapply(
  sample.ids.in.more.than.one.specimen.per.country, function(x) unique(x$Country))


  sample.ids.in.more.than.one.specimen.per.country.df=
    do.call(rbind, sample.ids.in.more.than.one.specimen.per.country)
  
 #delete rownames
rownames(sample.ids.in.more.than.one.specimen.per.country.df)=NULL
  
   # subset to specific country
sample.ids.in.more.than.one.specimen.per.country.df=
sample.ids.in.more.than.one.specimen.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(sample.ids.in.more.than.one.specimen.per.country.df)>0){  
  


    message("No. Not all sample IDs are under a single specimen These are the sample IDs repeated in more than one
specimen. Please scroll the table below down and left-right to see the complete dataset")

     
  kableExtra::kbl(sample.ids.in.more.than.one.specimen.per.country.df, 
                  caption = "Sample ids in more than one specimen per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2, border_right = T, width = "10em")%>%
    kableExtra::column_spec(3, border_right = T, width = "15em")%>%
    kableExtra::column_spec(4, border_right = T)%>%
    kableExtra::column_spec(5:6, border_right = T)%>%
    collapse_rows(columns = 4)%>%
    scroll_box(width = "100%", height = "600px")

}}

if(!exists("sample.ids.in.more.than.one.specimen.per.country.df") |
    exists("sample.ids.in.more.than.one.specimen.per.country.df") && 
   nrow(sample.ids.in.more.than.one.specimen.per.country.df)==0){  

    
     sample.ids.in.more.than.one.specimen.per.country=list(
      data.frame(Country="",
                Event_Code="",  
               Specimen_code="", 
               Sample_ID="", 
               Sample_type="",
               Medium_Type="",
               Date_Sampled=""
               ))
    
    rownames(sample.ids.in.more.than.one.specimen.per.country[[1]])<-NULL

  
  message("Yes, all sample IDs are under a single specimen")}

```
#### DATES
#
#
##### Were the samples collected since the date the corresponding event started?
#
```{r sample dates, echo=FALSE, warning=FALSE, eval=T, cache=F}


samples.sampled.before.event.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!is.na(Date_Sampled) & Has_sample_inventory=="Yes" & !is.na(Sample_type))%>%
    filter(!(as.Date(Start_date)<=as.Date(Date_Sampled)))%>%
    dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Start_date, Date_Sampled)%>%
    distinct(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Start_date, Date_Sampled))

# if there are rows with wrong latitude

if(nrow(do.call(rbind, samples.sampled.before.event.per.country))>0){  

  samples.sampled.before.event.per.country=
  do.call(
  rbind, samples.sampled.before.event.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)

# spit the data by country again now including the data of country based on the project tag
  
# for those rows wo country
samples.sampled.before.event.per.country=
lapply(sort(unique(samples.sampled.before.event.per.country$Country)), function(x) 
  samples.sampled.before.event.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)%>%
  distinct(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled))

# name the list
names(samples.sampled.before.event.per.country)=sapply(
  samples.sampled.before.event.per.country, function(x) unique(x$Country))
    

# order by specimen code
samples.sampled.before.event.per.country=
  lapply(samples.sampled.before.event.per.country, function(x)
  x[order(x$Country,
          x$Specimen_code),])


samples.sampled.before.event.per.country.df=
  do.call(
  rbind,
  samples.sampled.before.event.per.country)
   

#delete rownames
  rownames(samples.sampled.before.event.per.country.df)=NULL 

   # subset to specific country
samples.sampled.before.event.per.country.df=
samples.sampled.before.event.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(samples.sampled.before.event.per.country.df)>0){  
  
  
    message("No, the data show that some samples were collected before the event started. These are the samples that were
collected earlier than the beggining of the corresponding event")
  

    kableExtra::kbl(samples.sampled.before.event.per.country.df, 
                caption = "Samples with inconsistency between the event start date and the date they were collected") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:6,  border_right = T, width = "15em")
    
}}

if(!exists("samples.sampled.before.event.per.country.df") |
    exists("samples.sampled.before.event.per.country.df") && 
   nrow(samples.sampled.before.event.per.country.df)==0){  

  
  samples.sampled.before.event.per.country=list(
     data.frame(Country="",
               Event_Code="",    
               Specimen_code="", 
               Sample_ID="", 
               Sample_type="",
               Medium_Type="", 
               Date_Sampled=""))
   
  rownames(samples.sampled.before.event.per.country[[1]])<-NULL

  message("Yes, all samples were collected since the corresponding event started")}

```
#
#
##### Were the samples collected since the date the source specimen was found?
#
```{r sample dates 2, echo=FALSE, warning=FALSE, eval=T, cache=F}


samples.sampled.before.found.per.country=
  lapply(data.per.country.spec, function(x)
  x%>%
    filter(!is.na(Date_Sampled) & Has_sample_inventory=="Yes" & !is.na(Sample_type))%>%
    filter(!(as.Date(Date_Found)<=as.Date(Date_Sampled)))%>%
    dplyr::select(Country,Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Found, Date_Sampled)%>%
    distinct(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Found, Date_Sampled))

# if there are rows with wrong latitude

if(nrow(do.call(rbind, samples.sampled.before.found.per.country))>0){  

  samples.sampled.before.found.per.country=
  do.call(
  rbind, samples.sampled.before.found.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)

# spit the data by country again now including the data of country based on the project tag
  
# for those rows wo country
samples.sampled.before.found.per.country=
lapply(sort(unique(samples.sampled.before.found.per.country$Country)), function(x) 
  samples.sampled.before.found.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled)%>%
  distinct(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Date_Sampled))

# name the list
names(samples.sampled.before.found.per.country)=sapply(
  samples.sampled.before.found.per.country, function(x) unique(x$Country))
    

# order by specimen code
samples.sampled.before.found.per.country=
  lapply(samples.sampled.before.found.per.country, function(x)
    x[order(x$Country,
            x$Specimen_code),])



samples.sampled.before.found.per.country.df=
  do.call(
  rbind,
  samples.sampled.before.found.per.country)
   

#delete rownames
  rownames(samples.sampled.before.found.per.country.df)=NULL 

   # subset to specific country
samples.sampled.before.found.per.country.df=
samples.sampled.before.found.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(samples.sampled.before.found.per.country.df)>0){  
  
  #table 
    
  message("No, the data show that some samples were collected before the specimen was found. These are the samples that
were collected before the source specimen was found") 
  
  
  kableExtra::kbl(samples.sampled.before.found.per.country.df, 
                caption = "Samples with inconsistency between the date the source specimen was found and the date they were collected") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(c(2,5),  border_right = T, width = "12em")%>%
    kableExtra::column_spec(c(3,4,6),  border_right = T, width = "15em")
}}
  

if(!exists("samples.sampled.before.found.per.country.df") |
    exists("samples.sampled.before.found.per.country.df") && 
   nrow(samples.sampled.before.found.per.country.df)==0){  

   samples.sampled.before.found.per.country=list(
     data.frame(Country="",
                Event_Code="",
               Specimen_code="", 
               Sample_ID="", 
               Sample_type="",
               Medium_Type="",
               Date_Sampled=""))
   
  rownames(samples.sampled.before.event.per.country[[1]])<-NULL

  
  message("Yes, all samples were collected since the corresponding source specimen was found")}


```


<!-- ##### Were the specimens sampled same date or after the date they were received? -->

```{r sample dates 3, echo=FALSE, warning=FALSE, eval=F}


# indexes when the specimen was received before they were found
# na's are given when one of the rows is NA. Date found is not mandatory.
indexes.date.sampled.earlier.than.received=
  !(as.Date(spec$Date_Sampled) >= as.Date(spec$Date_Received))

#subset data for these specimens
samples.sampled.before.received=spec[which(indexes.date.sampled.earlier.than.received),c("Sample_ID", "Specimen_code", "Country", "Date_Received", "Date_Sampled")]

#removing rows with date received and found date as na and getting the specimen codes
samples.sampled.before.received.temp=
  samples.sampled.before.received[
  apply(samples.sampled.before.received, MARGIN = 1, function(x) !all(is.na(x))), c("Sample_ID", "Specimen_code", "Country")]

#list of specimen codes wo country whose dates received are earlier than day found
samples.sampled.before.received.2=list(samples.sampled.before.received.temp[is.na(samples.sampled.before.received.temp$Country), c("Sample_ID", "Specimen_code", "Country")])

#list of sample ids with country and specimen code whose dates of sample
# are earlier than day the event started

samples.sampled.before.received=
  lapply(sort(unique(samples.sampled.before.received.temp$Country)), function (x)
  unique(samples.sampled.before.received.temp[samples.sampled.before.received.temp$Country==x, c("Sample_ID", "Specimen_code")]))

samples.sampled.before.received=c(samples.sampled.before.received, samples.sampled.before.received.2)


#name the previous list
  names(samples.sampled.before.received)=
    c(sort(unique(samples.sampled.before.received.temp$Country)), "NA_Country")
    
#show the sample codes, specimen codes 
  samples.sampled.before.received.df= do.call(rbind,samples.sampled.before.received )
    
  #and the country
  samples.sampled.before.received.df$country=unlist(sapply(names(samples.sampled.before.received), function(x) 
      rep(x, nrow(samples.sampled.before.received[[x]]))), use.names = F)
   
  #table 
    
  if(length(unlist(samples.sampled.before.received))>0){

  message("Samples with inconsistent date sampled and date received 
           These are the sample ids with inconsistency between the date sampled
           and the date received")
  
  kableExtra::kbl(samples.sampled.before.received.df, 
                  caption = "Sample ids  with inconsistent date sampled and the date received") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T, width = "15em") %>%
    kableExtra::column_spec(2,  border_right = T, width = "10em")
} else{
  
  message("All sample ids have consistent sample date and the date received")}
```
#
#### QUANTITY
#
#
##### Are the sample quantities provided informative?
#
<!-- Problematic quantities must be identified using the "quantities.provided.per.country" -->
<!-- object (first object). -->

```{r sample quantity, echo=FALSE, warning=FALSE, eval=T, cache=F}

quantities.provided.per.country=sort(unique(
  unlist(
    lapply(data.per.country.spec, function(x)
  x%>%
  filter(Has_sample_inventory=="Yes")%>%  
  distinct(Quantity)), use.names = F)))

quantities.provided.per.country=quantities.provided.per.country[which(!is.na(as.numeric(quantities.provided.per.country)))]
  # quantities.provided.per.country[c(1:3, 5, 7, 14)]

problem.quantities=
  lapply(data.per.country.spec, function(x)
    x%>%filter(Quantity%in%quantities.provided.per.country)%>%
    dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Quantity, Date_Sampled))

    
if(nrow(do.call(rbind, problem.quantities))>0){  

  
  sample.ids.problem.quantities.per.country=
  do.call(
  rbind, problem.quantities)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Quantity, Date_Sampled)

# sort by sample ID
  
  sample.ids.problem.quantities.per.country=
    sample.ids.problem.quantities.per.country[order(
    sample.ids.problem.quantities.per.country$Country, 
    sample.ids.problem.quantities.per.country$Specimen_code),]

    
  
# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
sample.ids.problem.quantities.per.country=
lapply(sort(unique(sample.ids.problem.quantities.per.country$Country)), function(x) 
  sample.ids.problem.quantities.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Quantity, Date_Sampled))

sample.ids.problem.quantities.per.country=
lapply(sample.ids.problem.quantities.per.country, function(x)
  x%>%#group_by(Country, Event_Code, Sample_ID)%>%
  # mutate(Specimen_code=paste(Specimen_code, collapse = " "))%>%
  distinct(Country, Event_Code, Specimen_code, Sample_ID,  Sample_type, Medium_Type, Quantity, Date_Sampled))

# name the list
names(sample.ids.problem.quantities.per.country)=sapply(
  sample.ids.problem.quantities.per.country, function(x) unique(x$Country))


  sample.ids.problem.quantities.per.country.df=
    do.call(rbind, sample.ids.problem.quantities.per.country)

   #delete rownames
  rownames(sample.ids.problem.quantities.per.country.df)=NULL
  
 # subset to specific country
sample.ids.problem.quantities.per.country.df=
sample.ids.problem.quantities.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(sample.ids.problem.quantities.per.country.df)>0){  


    message("No. Not all the quantities provided are informative regarding the amount of sample. These are the IDs of those samples with non-informative quantities. Please scroll the table below down and left-right to see the complete
dataset")

    
  kableExtra::kbl(sample.ids.problem.quantities.per.country.df, 
                  caption = "Samples with non-informative quantities per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:6, border_right = T, width = "10em")%>%
    scroll_box(width = "100%", height = "600px")

}}

if(!exists("sample.ids.problem.quantities.per.country.df") |
    exists("sample.ids.problem.quantities.per.country.df") && 
   nrow(sample.ids.problem.quantities.per.country.df)==0){  

    
     sample.ids.problem.quantities.per.country=list(
      data.frame(Country="",
                Event_Code="",  
               Specimen_code="", 
               Sample_ID="", 
               Sample_type="",
               Medium_Type="",
               Quantity="",
               Date_Sampled=""
               ))
    
    rownames(sample.ids.problem.quantities.per.country[[1]])<-NULL

  
  message("Yes, all sample quantities provided are informative")}

```
#
#
### SUMMARY ISSUES AT THE SAMPLE LEVEL
#
"Yes" cells indicate problems for the item specified in the corresponding column name. Absence of a table below means that there are not issues at the sample level.
```{r summmary samples, echo=FALSE, warning=FALSE, eval=T, cache=F}

specimen.codes.with.sample.ids.as.na.per.country.df=
  
  do.call(rbind, specimen.codes.with.sample.ids.as.na.per.country)

specimen.codes.with.sample.ids.as.na.per.country.df$Sample_ID_is_NA="Yes"


# specimen.codes.with.wrong.sample.ids.per.country.df$Wrong_Sample_ID="Yes"

sample.ids.in.more.than.one.event.per.country.df=
  
  do.call(rbind, sample.ids.in.more.than.one.event.per.country)

sample.ids.in.more.than.one.event.per.country.df$Repeat_for_events="Yes"



sample.ids.in.more.than.one.specimen.per.country.df=
  
  do.call(rbind, sample.ids.in.more.than.one.specimen.per.country)

sample.ids.in.more.than.one.specimen.per.country.df$Repeat_for_specimens="Yes"



samples.sampled.before.event.per.country.df=
  
  do.call(rbind, samples.sampled.before.event.per.country)

samples.sampled.before.event.per.country.df$Sampled_before_event="Yes"




samples.sampled.before.found.per.country.df=
  
  do.call(rbind, samples.sampled.before.found.per.country)

samples.sampled.before.found.per.country.df$Sampled_before_found="Yes"




sample.ids.problem.quantities.per.country.df=
  
  do.call(rbind, sample.ids.problem.quantities.per.country)

sample.ids.problem.quantities.per.country.df$Non_informative_quantity="Yes"



# data showing the issues per Specimen code per country
# samples.with.issues=full_join(
#                               specimen.codes.with.sample.ids.as.na.per.country.df, 
#                               specimen.codes.with.wrong.sample.ids.per.country.df, 
#                               by=c("Country", "Event_Code", "Specimen_code", "Sample_ID", "Sample_type", "Medium_Type", "Date_Sampled"))

samples.with.issues=full_join(#samples.with.issues,
                              specimen.codes.with.sample.ids.as.na.per.country.df,
                              sample.ids.in.more.than.one.event.per.country.df, 
                              by=c("Country", "Event_Code", "Specimen_code", "Sample_ID", "Sample_type", "Medium_Type", "Date_Sampled"))

samples.with.issues=full_join(samples.with.issues,
                              sample.ids.in.more.than.one.specimen.per.country.df, 
                              by=c("Country", "Event_Code", "Specimen_code", "Sample_ID", "Sample_type", "Medium_Type", "Date_Sampled"))

samples.with.issues=full_join(samples.with.issues, 
                              samples.sampled.before.event.per.country.df, 
                              by=c("Country", "Event_Code", "Specimen_code", "Sample_ID", "Sample_type", "Medium_Type", "Date_Sampled"))

samples.with.issues=full_join(samples.with.issues,
                              samples.sampled.before.found.per.country.df,
                              by=c("Country", "Event_Code", "Specimen_code", "Sample_ID", "Sample_type", "Medium_Type", "Date_Sampled"))

samples.with.issues=full_join(samples.with.issues,
                              sample.ids.problem.quantities.per.country.df%>%
                                dplyr::select(-Quantity),
                              by=c("Country", "Event_Code", "Specimen_code", "Sample_ID", "Sample_type", "Medium_Type", "Date_Sampled"))


samples.with.issues=samples.with.issues%>%filter(Specimen_code!="")

samples.with.issues=samples.with.issues[order(
  samples.with.issues$Country,
  samples.with.issues$Specimen_code),]


rownames(samples.with.issues)=NULL

# subset to specific country
samples.with.issues=
  samples.with.issues%>%filter(Country==params$country.of.interest)


# subset to rows with at least one "Yes" 
  
samples.with.issues=
samples.with.issues %>%
   filter(rowSums(across(everything(), ~grepl("Yes", .x))) > 0)

if(nrow(samples.with.issues)>0){
  
  # removing columns were everything is NA
samples.with.issues=
samples.with.issues%>%dplyr::select_if(~ !all(is.na(.)))
  
      if(any(is.na(samples.with.issues))){
  samples.with.issues[is.na(samples.with.issues)]="No"}

  
message("Please scroll the table below down and left-right to see the complete dataset")  
  
 kableExtra::kbl(samples.with.issues,
                  caption = "Samples with problems per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(samples.with.issues), border_right = T, width = "20em")%>%
    scroll_box(width = "100%", height = "600px")

}else{
  message("No samples with problems")} 
```

## TESTS
Given the current status of the exported data from WHIP, I can only provide you the Specimen code that has samples with issues at the test level. You should search the Specimen code and go to the "Diseases" tab.
#
#### DATES
#
#
##### Were the tests sent for testing since the event started?
#
Only tests available for ASF for now.

```{r test dates, echo=FALSE, warning=FALSE, eval=T}

# list wht the filtering
test.sent.before.start.date.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_test_result) & 
         !is.na(Start_date))%>%
  filter(!(as.Date(Start_date) <=   
           as.Date(african_swine_fever_test_sent_for_testing)))%>% # start date is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
         #Sample_ID, Sample_type, Medium_Type, Quantity, Date_Sampled,
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  # distinct(Country, Event_Code, Specimen_code, Sample_ID, Sample_type, Medium_Type, Quantity, Date_Sampled, african_swine_fever_test_test_result))
  distinct(Country, Event_Code, Specimen_code, 
         #Sample_ID, Sample_type, Medium_Type, Quantity, Date_Sampled,
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing, 
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

if(nrow(do.call(rbind, test.sent.before.start.date.per.country))>0){

  test.sent.before.start.date.per.country=
  do.call(
  rbind, test.sent.before.start.date.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
        Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.sent.before.start.date.per.country=
lapply(sort(unique(test.sent.before.start.date.per.country$Country)), function(x) 
  test.sent.before.start.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.sent.before.start.date.per.country)=sapply(
  test.sent.before.start.date.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.sent.before.start.date.per.country.df=
do.call(rbind, test.sent.before.start.date.per.country)

#order by country and specimen code
test.sent.before.start.date.per.country.df=
  test.sent.before.start.date.per.country.df[order(
    test.sent.before.start.date.per.country.df$Country, 
    test.sent.before.start.date.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.sent.before.start.date.per.country.df)=NULL 

 # subset to specific country
test.sent.before.start.date.per.country.df=
test.sent.before.start.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.sent.before.start.date.per.country.df)>0){  
  
  
  message("No, data has some tests that were sent for testing before the corresponding event started. These
are the records showing inconsistency between the date the tests were sent for testing and the date
the event started")
  
  kableExtra::kbl(test.sent.before.start.date.per.country.df, 
                  caption = "Tests with inconsistency between the dates the event started and the date they were sent for testing")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.sent.before.start.date.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.sent.before.start.date.per.country.df") |
    exists("test.sent.before.start.date.per.country.df") && 
   nrow(test.sent.before.start.date.per.country.df)==0){  

    
     test.sent.before.start.date.per.country=list(
        data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.sent.before.start.date.per.country[[1]])<-NULL
  
  message("Yes, all tests were sent for testing since the event started")}

```
#
#
##### Were the tests sent for testing since the specimens were found?
#
Only tests available for ASF for now.
```{r test dates 2, echo=FALSE, warning=FALSE, eval=T}

# list wht the filtering
test.sent.before.date.found.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_test_result) &
         !is.na(Date_Found))%>%
  filter(!(as.Date(Date_Found) <=   
           as.Date(african_swine_fever_test_sent_for_testing)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code,
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
           african_swine_fever_test_test_result))
  

if(nrow(do.call(rbind, test.sent.before.date.found.per.country))>0){

  test.sent.before.date.found.per.country=
  do.call(
  rbind, test.sent.before.date.found.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.sent.before.date.found.per.country=
lapply(sort(unique(test.sent.before.date.found.per.country$Country)), function(x) 
  test.sent.before.date.found.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
          african_swine_fever_test_test_result))

# name the list
names(test.sent.before.date.found.per.country)=sapply(
  test.sent.before.date.found.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.sent.before.date.found.per.country.df=
do.call(rbind, test.sent.before.date.found.per.country)

#order by country and specimen code
test.sent.before.date.found.per.country.df=
  test.sent.before.date.found.per.country.df[order(
    test.sent.before.date.found.per.country.df$Country, 
    test.sent.before.date.found.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.sent.before.date.found.per.country.df)=NULL 

 # subset to specific country
test.sent.before.date.found.per.country.df=
test.sent.before.date.found.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.sent.before.date.found.per.country.df)>0){  
  
  
   message("No, data has some tests that were sent for testing before the corresponding specimen was found. 
These are the records showing inconsistency between the date tests were sent and the date the specimen was found")

  kableExtra::kbl(test.sent.before.date.found.per.country.df, 
                  caption = "Tests with inconsistency between the dates the specimen was found and the date they were sent for testing")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.sent.before.date.found.per.country.df), border_right = T, width = "10em")
  }}
    
if(!exists("test.sent.before.date.found.per.country.df") |
    exists("test.sent.before.date.found.per.country.df") && 
   nrow(test.sent.before.date.found.per.country.df)==0){  


     test.sent.before.date.found.per.country=list(
       data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.sent.before.date.found.per.country[[1]])<-NULL
  
  message("Yes, all tests were sent for testing since the specimens were found")}


```

#
#
##### Were the test sent for testing since the specimens were received?
#
Only tests available for ASF for now.

```{r test dates 3, echo=FALSE, warning=FALSE, eval=T}

# list wht the filtering
test.sent.before.date.received.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_test_result) &
         !is.na(Date_Received))%>%
  filter(!(as.Date(Date_Received) <=   
           as.Date(african_swine_fever_test_sent_for_testing)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
        Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
           african_swine_fever_test_test_result))
  

if(nrow(do.call(rbind, test.sent.before.date.received.per.country))>0){

  test.sent.before.date.received.per.country=
  do.call(
  rbind, test.sent.before.date.received.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.sent.before.date.received.per.country=
lapply(sort(unique(test.sent.before.date.received.per.country$Country)), function(x) 
  test.sent.before.date.received.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code,
        Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.sent.before.date.received.per.country)=sapply(
  test.sent.before.date.received.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.sent.before.date.received.per.country.df=
do.call(rbind, test.sent.before.date.received.per.country)

#order by country and specimen code
test.sent.before.date.received.per.country.df=
  test.sent.before.date.received.per.country.df[order(
    test.sent.before.date.received.per.country.df$Country, 
    test.sent.before.date.received.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.sent.before.date.received.per.country.df)=NULL 
  
 # subset to specific country
test.sent.before.date.received.per.country.df=
test.sent.before.date.received.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.sent.before.date.received.per.country.df)>0){  

  
   message("No, data has some tests that were sent for testing before the corresponding specimen was received. These are the records showing inconsistency between the date tests were sent and the date the specimen was received")
  
  kableExtra::kbl(test.sent.before.date.received.per.country.df, 
                  caption = "Tests with inconsistent date sent for testing and specimen received")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.sent.before.date.received.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.sent.before.date.received.per.country.df") |
    exists("test.sent.before.date.received.per.country.df") && 
   nrow(test.sent.before.date.received.per.country.df)==0){
    
     test.sent.before.date.received.per.country=list(
        data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.sent.before.date.received.per.country[[1]])<-NULL
  
  message("Yes, all tests were sent for testing since the specimens were received")}

```
#
#
##### Were the tests sent for testing after the samples were taken?
#
Only tests available for ASF for now.
```{r test dates 4, echo=FALSE, warning=FALSE, eval=T}


# list wht the filtering
test.sent.before.date.sampled.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_test_result) &
         !is.na(Date_Sampled))%>%
  filter(!(as.Date(Date_Sampled) <=   
           as.Date(african_swine_fever_test_sent_for_testing)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))
  


test.sent.before.date.sampled.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_test_result) &
         !is.na(Date_Sampled))%>%
  filter(!(as.Date(Date_Sampled) <=   
           as.Date(african_swine_fever_test_sent_for_testing)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
            Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received, 
         african_swine_fever_test_test_result))
  


if(nrow(do.call(rbind, test.sent.before.date.sampled.per.country))>0){

  test.sent.before.date.sampled.per.country=
  do.call(
  rbind, test.sent.before.date.sampled.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.sent.before.date.sampled.per.country=
lapply(sort(unique(test.sent.before.date.sampled.per.country$Country)), function(x) 
  test.sent.before.date.sampled.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.sent.before.date.sampled.per.country)=sapply(
  test.sent.before.date.sampled.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.sent.before.date.sampled.per.country.df=
do.call(rbind, test.sent.before.date.sampled.per.country)

#order by country and specimen code
test.sent.before.date.sampled.per.country.df=
  test.sent.before.date.sampled.per.country.df[order(
    test.sent.before.date.sampled.per.country.df$Country, 
    test.sent.before.date.sampled.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.sent.before.date.sampled.per.country.df)=NULL 
  
   # subset to specific country
test.sent.before.date.sampled.per.country.df=
test.sent.before.date.sampled.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.sent.before.date.sampled.per.country.df)>0){  

  
    message("No, data has some tests that were sent for testing before the sample was collected. These are the records showing inconsistency between the date tests were sent and the date the samples were collected")
  
  kableExtra::kbl(test.sent.before.date.sampled.per.country.df, 
                  caption = "Tests with inconsistent dates of sent for testing and sample collected")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.sent.before.date.sampled.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.sent.before.date.sampled.per.country.df") |
    exists("test.sent.before.date.sampled.per.country.df") && 
   nrow(test.sent.before.date.sampled.per.country.df)==0){

    
     test.sent.before.date.sampled.per.country=list(
        data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.sent.before.date.sampled.per.country[[1]])<-NULL
  
  message("Yes, all tests were sent for testing since the samples were taken")}

```
#
#
##### Were the tests results received after the event started?
#
Only tests available for ASF for now.
```{r test dates 5, echo=FALSE, warning=FALSE, eval=T}

# list with the filtering
test.results.received.before.start.date.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_results_received) &
         !is.na(Start_date))%>%
  filter(!(as.Date(Start_date) <=   
           as.Date(african_swine_fever_test_results_received)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code,
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
           african_swine_fever_test_test_result))
  

if(nrow(do.call(rbind, test.results.received.before.start.date.per.country))>0){

  test.results.received.before.start.date.per.country=
  do.call(
  rbind, test.results.received.before.start.date.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.results.received.before.start.date.per.country=
lapply(sort(unique(test.results.received.before.start.date.per.country$Country)), function(x) 
  test.results.received.before.start.date.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.results.received.before.start.date.per.country)=sapply(
  test.results.received.before.start.date.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.results.received.before.start.date.per.country.df=
do.call(rbind, test.results.received.before.start.date.per.country)

#order by country and specimen code
test.results.received.before.start.date.per.country.df=
  test.results.received.before.start.date.per.country.df[order(
    test.results.received.before.start.date.per.country.df$Country, 
    test.results.received.before.start.date.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.results.received.before.start.date.per.country.df)=NULL 

   # subset to specific country
test.results.received.before.start.date.per.country.df=
test.results.received.before.start.date.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.results.received.before.start.date.per.country.df)>0){  
  
  
     message("No, data has some test results that were received before the event started. These are the records showing inconsistency between the date test results were received and the date the event started")
  
  kableExtra::kbl(test.results.received.before.start.date.per.country.df, 
                  caption = "Tests with inconsistent dates of test results received and start of the event")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.results.received.before.start.date.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.results.received.before.start.date.per.country.df") |
    exists("test.results.received.before.start.date.per.country.df") && 
   nrow(test.results.received.before.start.date.per.country.df)==0){

    
     test.results.received.before.start.date.per.country=list(
        data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.results.received.before.start.date.per.country[[1]])<-NULL
  
  message("Yes, all test results were received since the event started")}

```
#
#
##### Were the tests results received after the specimens were found?
#
Only tests available for ASF for now.
```{r test dates 6, echo=FALSE, warning=FALSE, eval=T}

# list with the filtering
test.results.received.before.found.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_results_received) &
         !is.na(Date_Found))%>%
  filter(!(as.Date(Date_Found) <=   
           as.Date(african_swine_fever_test_results_received)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
           african_swine_fever_test_test_result))
  

if(nrow(do.call(rbind, test.results.received.before.found.per.country))>0){

  test.results.received.before.found.per.country=
  do.call(
  rbind, test.results.received.before.found.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
          african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.results.received.before.found.per.country=
lapply(sort(unique(test.results.received.before.found.per.country$Country)), function(x) 
  test.results.received.before.found.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code,
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
        african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code,
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.results.received.before.found.per.country)=sapply(
  test.results.received.before.found.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.results.received.before.found.per.country.df=
do.call(rbind, test.results.received.before.found.per.country)

#order by country and specimen code
test.results.received.before.found.per.country.df=
  test.results.received.before.found.per.country.df[order(
    test.results.received.before.found.per.country.df$Country, 
    test.results.received.before.found.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.results.received.before.found.per.country.df)=NULL 

   # subset to specific country
test.results.received.before.found.per.country.df=
test.results.received.before.found.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.results.received.before.found.per.country.df)>0){  
  
  
      message("No, data has some test results that were received before the corresponding specimen was found. These are the records showing inconsistency between the date test results were received and the date the specimen was found")
  
  kableExtra::kbl(test.results.received.before.found.per.country.df, 
                  caption = "Tests with inconsistent dates of test results received and specimen found")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.results.received.before.found.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.results.received.before.found.per.country.df") |
    exists("test.results.received.before.found.per.country.df") && 
   nrow(test.results.received.before.found.per.country.df)==0){

    
     test.results.received.before.found.per.country=list(
        data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.results.received.before.found.per.country[[1]])<-NULL
  
  message("Yes, all test results were received since the correspoding specimen was found")}

```
#
#
##### Were the tests results received after the specimens were received?
#
Only tests available for ASF for now.
```{r test dates 7, echo=FALSE, warning=FALSE, eval=T}

# list with the filtering
test.results.received.before.specimens.received.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_results_received) &
         !is.na(Date_Received))%>%
  filter(!(as.Date(Date_Received) <=   
           as.Date(african_swine_fever_test_results_received)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
            Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
           african_swine_fever_test_test_result))
  

if(nrow(do.call(rbind, test.results.received.before.specimens.received.per.country))>0){

  test.results.received.before.specimens.received.per.country=
  do.call(
  rbind, test.results.received.before.specimens.received.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.results.received.before.specimens.received.per.country=
lapply(sort(unique(test.results.received.before.specimens.received.per.country$Country)), function(x) 
  test.results.received.before.specimens.received.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         Date_Received, african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.results.received.before.specimens.received.per.country)=sapply(
  test.results.received.before.specimens.received.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.results.received.before.specimens.received.per.country.df=
do.call(rbind, test.results.received.before.specimens.received.per.country)

#order by country and specimen code
test.results.received.before.specimens.received.per.country.df=
  test.results.received.before.specimens.received.per.country.df[order(
    test.results.received.before.specimens.received.per.country.df$Country, 
    test.results.received.before.specimens.received.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.results.received.before.specimens.received.per.country.df)=NULL 

   # subset to specific country
test.results.received.before.specimens.received.per.country.df=
test.results.received.before.specimens.received.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.results.received.before.specimens.received.per.country.df)>0){  
  
  
       message("No, data has some test results that were received before the corresponding specimen was received. These are the records showing inconsistency between the date test results were received and the date the specimen was received")
  
  kableExtra::kbl(test.results.received.before.specimens.received.per.country.df, 
                  caption = "Tests with inconsistent dates of test results received and specimen received")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.results.received.before.specimens.received.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.results.received.before.specimens.received.per.country.df") |
    exists("test.results.received.before.specimens.received.per.country.df") && 
   nrow(test.results.received.before.specimens.received.per.country.df)==0){

    
     test.results.received.before.specimens.received.per.country=list(
        data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.results.received.before.specimens.received.per.country[[1]])<-NULL
  
  message("Yes, all test results were received since the correspoding specimens were
received")}

```
#
#
##### Were the tests results received after the samples were taken?
#
Only tests available for ASF for now.
```{r test dates 8, echo=FALSE, warning=FALSE, eval=T}

# list with the filtering
test.results.received.before.samples.taken.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_results_received) &
         !is.na(Date_Sampled))%>%
  filter(!(as.Date(Date_Sampled) <=   
           as.Date(african_swine_fever_test_results_received)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
          african_swine_fever_test_test_result))
  

if(nrow(do.call(rbind, test.results.received.before.samples.taken.per.country))>0){

  test.results.received.before.samples.taken.per.country=
  do.call(
  rbind, test.results.received.before.samples.taken.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.results.received.before.samples.taken.per.country=
lapply(sort(unique(test.results.received.before.samples.taken.per.country$Country)), function(x) 
  test.results.received.before.samples.taken.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
           Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.results.received.before.samples.taken.per.country)=sapply(
  test.results.received.before.samples.taken.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.results.received.before.samples.taken.per.country.df=
do.call(rbind, test.results.received.before.samples.taken.per.country)

#order by country and specimen code
test.results.received.before.samples.taken.per.country.df=
  test.results.received.before.samples.taken.per.country.df[order(
    test.results.received.before.samples.taken.per.country.df$Country, 
    test.results.received.before.samples.taken.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.results.received.before.samples.taken.per.country.df)=NULL 

   # subset to specific country
test.results.received.before.samples.taken.per.country.df=
test.results.received.before.samples.taken.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.results.received.before.samples.taken.per.country.df)>0){  
  
  
        message("No, data has some test results that were received before the corresponding sample was collected. These are the records showing inconsistency between the date test results were received and the date the sample was collected")
 
  kableExtra::kbl(test.results.received.before.samples.taken.per.country.df, 
                  caption = "Tests with inconsistent dates of test results received and sample collected")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.results.received.before.samples.taken.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.results.received.before.samples.taken.per.country.df") |
    exists("test.results.received.before.samples.taken.per.country.df") && 
   nrow(test.results.received.before.samples.taken.per.country.df)==0){

    
     test.results.received.before.samples.taken.per.country=list(
       data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))

    
    rownames(test.results.received.before.samples.taken.per.country[[1]])<-NULL
  
  message("Yes, all test results were received since the correspoding sample was collected")}

```
#
#
##### Were the tests results received after the tests were sent for testing?
#
Only tests available for ASF for now.
```{r test dates 9, echo=FALSE, warning=FALSE, eval=T}

# list with the filtering
test.results.received.before.sent.for.testing.per.country=
lapply(data.per.country.spec, function(x) 
  x%>%
  filter(!is.na(african_swine_fever_test_results_received) &
         !is.na(african_swine_fever_test_sent_for_testing))%>%
  filter(!(as.Date(african_swine_fever_test_sent_for_testing) <=   
           as.Date(african_swine_fever_test_results_received)))%>% # start datae is not before that testing
  dplyr::select(Country, Event_Code, Specimen_code,
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
           african_swine_fever_test_test_result))
  

if(nrow(do.call(rbind, test.results.received.before.sent.for.testing.per.country))>0){

  test.results.received.before.sent.for.testing.per.country=
  do.call(
  rbind, test.results.received.before.sent.for.testing.per.country)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)

# spit the data by country again now including the data of country based on the project tag
# for those rows wo country
test.results.received.before.sent.for.testing.per.country=
lapply(sort(unique(test.results.received.before.sent.for.testing.per.country$Country)), function(x) 
  test.results.received.before.sent.for.testing.per.country%>%filter(Country==x)%>%
  dplyr::select(Country, Event_Code, Specimen_code, 
         Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result)%>%
  distinct(Country, Event_Code, Specimen_code, 
          Start_date,
         Date_Found, Date_Received, Date_Sampled,
         african_swine_fever_test_sent_for_testing,
         african_swine_fever_test_results_received,
         african_swine_fever_test_test_result))

# name the list
names(test.results.received.before.sent.for.testing.per.country)=sapply(
  test.results.received.before.sent.for.testing.per.country, function(x) unique(x$Country))
    

# move to da dataset with the event codes in a single row
test.results.received.before.sent.for.testing.per.country.df=
do.call(rbind, test.results.received.before.sent.for.testing.per.country)

#order by country and specimen code
test.results.received.before.sent.for.testing.per.country.df=
  test.results.received.before.sent.for.testing.per.country.df[order(
    test.results.received.before.sent.for.testing.per.country.df$Country, 
    test.results.received.before.sent.for.testing.per.country.df$Specimen_code),]
    
   #delete rownames
  rownames(test.results.received.before.sent.for.testing.per.country.df)=NULL 

   # subset to specific country
test.results.received.before.sent.for.testing.per.country.df=
test.results.received.before.sent.for.testing.per.country.df%>%filter(Country==params$country.of.interest)

if(nrow(test.results.received.before.sent.for.testing.per.country.df)>0){  
  
  
        message("No, data has some test results that were received before the sample was sent for testing. These are the records showing inconsistency between the date test results were received and the date the sample was sent for testing")
  
  kableExtra::kbl(test.results.received.before.sent.for.testing.per.country.df, 
                  caption = "Tests with inconsistent dates of test results received and sent for testing")%>%
                  kableExtra::kable_paper(full_width = F) %>%
                  kableExtra::column_spec(1, bold = T, border_right = T) %>%
                  kableExtra::column_spec(2:ncol(test.results.received.before.sent.for.testing.per.country.df), border_right = T, width = "10em")
}}

if(!exists("test.results.received.before.sent.for.testing.per.country.df") |
    exists("test.results.received.before.sent.for.testing.per.country.df") && 
   nrow(test.results.received.before.sent.for.testing.per.country.df)==0){

    
     test.results.received.before.sent.for.testing.per.country=list(
      data.frame(Country="", 
                 Event_Code="", 
                 Specimen_code="", 
         Start_date="",
         Date_Found="", Date_Received="", Date_Sampled="",
         african_swine_fever_test_sent_for_testing="",
         african_swine_fever_test_results_received="",
         african_swine_fever_test_test_result=""))
    
    rownames(test.results.received.before.sent.for.testing.per.country[[1]])<-NULL
  
  message("Yes, all test results were received since the correspoding sample was sent for
testing")}

```
#
#
### SUMMARY ISSUES AT THE TEST LEVEL
#
"Yes" cells indicate problems for the item specified in the corresponding column name. Absence of a table below means that there are not issues at the test level.

```{r summmary tests, echo=FALSE, warning=FALSE, eval=T, cache=F}

test.sent.before.start.date.per.country.df=do.call(rbind,test.sent.before.start.date.per.country)
test.sent.before.start.date.per.country.df$sent_testing_before_event="Yes"

test.sent.before.date.found.per.country.df=do.call(rbind,test.sent.before.date.found.per.country)
test.sent.before.date.found.per.country.df$sent_testing_before_found="Yes"

test.sent.before.date.received.per.country.df=do.call(rbind,test.sent.before.date.received.per.country)
test.sent.before.date.received.per.country.df$sent_testing_before_received="Yes"

test.sent.before.date.sampled.per.country.df=do.call(rbind,test.sent.before.date.sampled.per.country)
test.sent.before.date.sampled.per.country.df$sent_testing_before_sampled="Yes"

test.results.received.before.start.date.per.country.df=do.call(rbind,test.results.received.before.start.date.per.country)
test.results.received.before.start.date.per.country.df$results_before_event="Yes"

test.results.received.before.found.per.country.df=do.call(rbind,test.results.received.before.found.per.country)
test.results.received.before.found.per.country.df$results_before_found="Yes"

test.results.received.before.specimens.received.per.country.df=do.call(rbind,test.results.received.before.specimens.received.per.country)
test.results.received.before.specimens.received.per.country.df$results_before_received="Yes"

test.results.received.before.samples.taken.per.country.df=do.call(rbind,test.results.received.before.samples.taken.per.country)
test.results.received.before.samples.taken.per.country.df$results_before_taken="Yes"

test.results.received.before.sent.for.testing.per.country.df=do.call(rbind,test.results.received.before.sent.for.testing.per.country)
test.results.received.before.sent.for.testing.per.country.df$results_before_testing="Yes"


# data showing the issues per Test  per country
tests.with.issues=full_join(test.sent.before.start.date.per.country.df,
                              test.sent.before.date.found.per.country.df,
                              by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))

tests.with.issues=full_join(tests.with.issues, 
                              test.sent.before.date.received.per.country.df,
                             by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))

tests.with.issues=full_join(tests.with.issues,
                              test.sent.before.date.sampled.per.country.df, 
                                by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))

tests.with.issues=full_join(tests.with.issues, 
                              test.results.received.before.start.date.per.country.df, 
                                 by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))

tests.with.issues=full_join(tests.with.issues,
                              test.results.received.before.found.per.country.df,
                              by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))

tests.with.issues=full_join(tests.with.issues,
                              test.results.received.before.specimens.received.per.country.df,
                                 by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))

tests.with.issues=full_join(tests.with.issues,
                              test.results.received.before.samples.taken.per.country.df,
                             by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))


tests.with.issues=full_join(tests.with.issues,
                              test.results.received.before.sent.for.testing.per.country.df,
                                  by=c("Country", "Event_Code", "Specimen_code", 
                                   "Start_date", "Date_Found", "Date_Received", "Date_Sampled",
                                   "african_swine_fever_test_sent_for_testing",
                                   "african_swine_fever_test_results_received",
                                   "african_swine_fever_test_test_result"))

tests.with.issues=tests.with.issues[tests.with.issues$Event_Code!="",]


tests.with.issues=tests.with.issues[order(
  tests.with.issues$Country,
  tests.with.issues$Specimen_code),]


rownames(tests.with.issues)=NULL


# subset to specific country
tests.with.issues=
  tests.with.issues%>%filter(Country==params$country.of.interest)


if(nrow(tests.with.issues)>0){
  
  
  # removing columns were everything is NA
tests.with.issues=
tests.with.issues%>%dplyr::select_if(~ !all(is.na(.)))
  
        if(any(is.na(tests.with.issues))){
  tests.with.issues[is.na(tests.with.issues)]="No"}
  
message("Please scroll the table below down and left-right to see the complete dataset")  
  
 kableExtra::kbl(tests.with.issues,
                  caption = "Tests with problems per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(tests.with.issues), border_right = T, width = "20em")%>%
    scroll_box(width = "100%", height = "600px")

}else{
  message("No tests with problems")} 
```
#
## SAMPLE SOURCE
#
#
##### Is the sample source provided for the tests conducted? "No", means the sample source is not provided.
#
```{r summmary sample source, echo=FALSE, warning=T, eval=T, cache=F, message=F}


# columns with tests results
all_tests_results=sort(grep("test_test_result|pcr_test_result", colnames(spec), value = T))
all_tests_results=all_tests_results[all_tests_results!="rabies_test_test_result"]

#modify
all_tests_sample_source=sort(grep("sample_source", colnames(spec), value = T))


test=sapply(strsplit(all_tests_results, "_"), function(x) paste0(x[1:2], collapse = "_"))


all_tests_sample_source=lapply(test, function(x) grep(x, all_tests_sample_source, value = T))



out=vector(mode = "list", length = length(all_tests_sample_source))

for(i in 1:length(all_tests_sample_source)){

varname <- paste0(all_tests_results[i], "_sample_source")
  
  
out[[i]]=spec%>%filter(Country==params$country.of.interest & !is.na(get(all_tests_results[i])) & is.na(get(all_tests_sample_source[[i]])))%>%
  dplyr::select(Country,
         Specimen_code,
         all_tests_sample_source[[i]],
         all_tests_results[i],
         Sample_type)%>%arrange(Specimen_code)%>%
        dplyr::mutate(!!varname:="No")%>%
  dplyr::select(Country,
         Specimen_code,
         varname)


}


sample.source.not.provided.per.country.df=join_all(out, by=c("Country", "Specimen_code"), type='full')


if(nrow(sample.source.not.provided.per.country.df)>0){  

  
  # removing columns were everything is NA
sample.source.not.provided.per.country.df=
sample.source.not.provided.per.country.df%>%dplyr::select_if(~ !all(is.na(.)))
  
if(any(is.na(sample.source.not.provided.per.country.df))){
  sample.source.not.provided.per.country.df[is.na(sample.source.not.provided.per.country.df)]="Yes"}

  message("Not all Sample sources for testing are provided.
These are the Specimens with tests whose source is not provided.
Please scroll the table below down and left-right to see the complete dataset")
  
  kableExtra::kbl(sample.source.not.provided.per.country.df, 
                      caption = "Tests without sample source per country") %>%
    kableExtra::kable_paper(full_width = F) %>%
    kableExtra::column_spec(1, bold = T, border_right = T) %>%
    kableExtra::column_spec(2:ncol(sample.source.not.provided.per.country.df), border_right = T, width = "15em")%>%
    scroll_box(width = "100%", height = "600px")

  # print(specimen.codes.with.animal.ids.as.na.per.country)
}else{message("All sample sources are provided for the tests conducted")}

```